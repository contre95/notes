<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clean Architecture - Lucas Contre</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../../tech/notes/index.html"><strong aria-hidden="true">1.</strong> Notes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/enterprise-arch.html"><strong aria-hidden="true">1.1.</strong> Eneterprise Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/enterprise-arch/lawsnprinciples.html"><strong aria-hidden="true">1.1.1.</strong> Laws and Principle</a></li></ol></li><li class="chapter-item expanded "><a href="../../../tech/notes/software-arch/index.html"><strong aria-hidden="true">1.2.</strong> Software Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../tech/notes/software-arch/clean-arch.html" class="active"><strong aria-hidden="true">1.2.1.</strong> Clean Architecture</a></li><li class="chapter-item "><a href="../../../tech/notes/software-arch/ddd.html"><strong aria-hidden="true">1.2.2.</strong> Domain Driven Design</a></li><li class="chapter-item "><a href="../../../tech/notes/software-arch/lawsnprinciples.html"><strong aria-hidden="true">1.2.3.</strong> Laws and Principle</a></li></ol></li><li class="chapter-item "><a href="../../../tech/notes/linux/index.html"><strong aria-hidden="true">1.3.</strong> Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/linux/which-distro.html"><strong aria-hidden="true">1.3.1.</strong> Which Linux Distro ?</a></li><li class="chapter-item "><a href="../../../tech/notes/linux/capabilities.html"><strong aria-hidden="true">1.3.2.</strong> Capabilities</a></li><li class="chapter-item "><a href="../../../tech/notes/linux/checking-system-performance.html"><strong aria-hidden="true">1.3.3.</strong> Performance check</a></li><li class="chapter-item "><a href="../../../tech/notes/ssh/tunneling.html"><strong aria-hidden="true">1.3.4.</strong> ssh</a></li><li class="chapter-item "><a href="../../../tech/notes/linux/systemd/systemd.html"><strong aria-hidden="true">1.3.5.</strong> Systemd</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/linux/systemd/journalctl.html"><strong aria-hidden="true">1.3.5.1.</strong> Journal</a></li></ol></li><li class="chapter-item "><a href="../../../tech/notes/linux/containers/index.html"><strong aria-hidden="true">1.3.6.</strong> Containers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/linux/containers/podman.html"><strong aria-hidden="true">1.3.6.1.</strong> Podman</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../tech/notes/philosphy.html"><strong aria-hidden="true">1.4.</strong> Software Philosphy</a></li><li class="chapter-item "><a href="../../../tech/notes/security.html"><strong aria-hidden="true">1.5.</strong> Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/notes/security/tls.html"><strong aria-hidden="true">1.5.1.</strong> TLS</a></li></ol></li><li class="chapter-item "><a href="../../../tech/notes/abstractions.html"><strong aria-hidden="true">1.6.</strong> Designing Abstractions</a></li></ol></li><li class="chapter-item expanded "><a href="../../../tech/copy-paste/index.html"><strong aria-hidden="true">2.</strong> Copy/Paste</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../tech/copy-paste/cloud/oneliners.html"><strong aria-hidden="true">2.1.</strong> Cloud</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/terminal/shell.html"><strong aria-hidden="true">2.2.</strong> Shell</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/terminal/arch.html"><strong aria-hidden="true">2.3.</strong> Arch</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/containers/oneliners.html"><strong aria-hidden="true">2.4.</strong> Containers</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/cloud/k8s.html"><strong aria-hidden="true">2.5.</strong> K8S</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/networking/oneliners.html"><strong aria-hidden="true">2.6.</strong> Networking</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/databases/mysql.html"><strong aria-hidden="true">2.7.</strong> MySQL</a></li><li class="chapter-item "><a href="../../../tech/copy-paste/git/git.html"><strong aria-hidden="true">2.8.</strong> Git</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lucas Contre</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clean-architecture"><a class="header" href="#clean-architecture">Clean Architecture</a></h1>
<p>This are literal highlights from the <a href="https://books.google.es/books/about/Clean_Architecture.html?id=uGE1DwAAQBAJ&amp;source=kp_book_description&amp;redir_esc=y">Clean Architecture book</a> written by Robert C. Martin (Uncle Bob)</p>
<p>You can read his blog <a href="https://blog.cleancoder.com/">here</a></p>
<h2 id="foreword"><a class="header" href="#foreword">Foreword</a></h2>
<p>Describing software through architecture can reveal as much as it hides. It can
both promise more than what it can delivers and deliver more than what it
promises.</p>
<p><em>Architecture represents the significant design decisions that shape a system,
where significant is measured by cost of change.</em> - <em>Grady Booch</em></p>
<p>Time, money and effort give us a sense of scale to short between the large and
the small, to distinguish the architectural stuff from the rest. A good
architecture should not only meet the need of its users, developers, and owners
at a given point in time, but it also meets them over time.</p>
<p><em>If you think good architecture is expensive, try bad architecture.</em> - <em>Brian
Foote and Joseph Yoder</em></p>
<p>The path we are most interested is  the cleanest one, where we recognize the
softness of software and preserve it as a first-class property of the system.
Recognize that we operate with incomplete knowledge, but also understand that as
humans is something we're good at. Play more to our strength than to our
weaknesses. </p>
<p><em>Architecture is a hypothesis, that needs to be proven by implementation and
measurement.</em> - <em>Tom Glib</em></p>
<p>To walk this path requires care and attention, thought and observation, practice
and principle.  This at first might sound slow, but it's all in the way that you
walk.</p>
<p><em>Slow and steady wins the race.</em></p>
<h2 id="preface"><a class="header" href="#preface">Preface</a></h2>
<p>Uncle Bob claims to have taken part and tons of different systems from games to
multi-threaded, multi processor, GUI and databases apes and all of them follows
the same rules.</p>
<p>He concludes &quot;<em>the rules of software architecture are independent of every other
variable.</em>&quot; He based on the fact that even though technology has improved
drastically in term of new hardware more libraries and new languages, the bases
are the same. It's made of the same stuff. It's made of <code>if</code> statements,
assignments statements, and <code>while</code> loops. This changeless NESS of the code is
the reason that the rules o software architecture are so consistent across
system types. Nevertheless, one thing has changed: Back then, they didn't know
what the rules were.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Getting something to work --once-- just isn't that hard. Getting it right is
another matter entirely. Getting software right is hard and most young
programmers don't have what it needs or simply doesn't care about writing clean
code.</p>
<p>When you get software right, something magical happens: You don't need hordes of
programmers to keep it working. You don't need massive requirements documents
and huge issue tracking systems. When software is done right it requires a
fraction the human resources to create and maintain.</p>
<p>Unfortunately, It is far more common to fight your way through terrible software
designs that it is to enjoy the pleasure of working with a good one.</p>
<h1 id="part-i-what-is-design-and-architecture-"><a class="header" href="#part-i-what-is-design-and-architecture-">Part I: What is design and architecture ?</a></h1>
<p>There has been a lot of confusion about design and architecture over the years
and one of the goals of this book is to cu through all that confusion and to
define what architecture and design are. For starters, there's no difference at
all.</p>
<p>The work <em>architecture</em> is often used in the context of something at a high
level that is divorced from the lower-level details, whereas <em>design</em> more often
seems to imply structures and decisions at a lower level. But this usage is
nonsensical when you look at what a real architect does. </p>
<h3 id="the-goal"><a class="header" href="#the-goal">The goal</a></h3>
<p>Both design and architecture can be used to describe a continuum of decisions
from the highest to the lowest levels. And what drives that decision ? </p>
<p><em>The goal of software architecture is to minimize the human resources required
to build and maintain the required system.</em></p>
<p>Once again like in the foreword remark the importance of taking the time to
think thing through by stating several quotes and showing a case study on the
matter.</p>
<p><em>The race is not to the swift, nor the battle to the strong.</em></p>
<p><em>The more haste, the less speed.</em></p>
<p><em>Making messes is always slower than staying clean.</em></p>
<p><em>The only way of going fast, is to go well</em></p>
<p>The developers may think that the answer is to sart over from scratch and
redesign the whole system --  but that's just the hare talking again.</p>
<p><em>Their overconfidence will drive the redesign into the same mess as the original
project.</em></p>
<h2 id="a-tale-of-two-values"><a class="header" href="#a-tale-of-two-values">A tale of two values</a></h2>
<p>Uncle bob says that software mainly provide two values: <strong>Behavior</strong> and
<strong>Architecture</strong>. </p>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<p><strong>Behavior</strong> , making a machine behave in a way that meets the stakeholders
requirements. Functionality. Some programmers think this is their entire job.
They think that their job is to implement requirements and fix bugs. They are
sadly wrong.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p><strong>Architecture</strong>, has to do with the word software. <em>ware</em> being product and the
word <em>soft</em> that is where the second value lies.</p>
<p>Software was invented to be <em>soft</em>. It was intended to be a way to easily change
the behavior of machines. If we'd wanted the behavior of machines to be hard to
change, we would have called it <em>hardware</em>.</p>
<p>Architecture should be agnostics of shape.</p>
<h3 id="eisenhower-matrix"><a class="header" href="#eisenhower-matrix">Eisenhower Matrix:</a></h3>
<p><em>The urgent is not important and the important are never urgent.</em> </p>
<p>Those things that are urgent are rarely of great importance, and those things
that are important are seldom of great urgency.</p>
<p>The first value of software --behavior-- is urgent but not always important.</p>
<p>The second value of software --architecture-- is important but never
particularly urgent.</p>
<ol>
<li>Urgent and Important</li>
<li>Not urgent and important</li>
<li>Urgent and not important</li>
<li>Not Urgent and not important</li>
</ol>
<p>Business managers and developers often place the 3 option to the first place.</p>
<h1 id="part-ii-starting-from-the-brick-programming-paradigms"><a class="header" href="#part-ii-starting-from-the-brick-programming-paradigms">Part II: Starting from the brick: Programming paradigms</a></h1>
<p>First programming revolution was that of languages. Languages relieved the
programmers of the drudgery of translating their programs into binary.</p>
<p>Another revolution, probably more significant, revolution was in programming
paradigms. Paradigms area ways of programming, relatively unrelated to
languages. <em><strong>A paradigm tells you which programming structures to use, and when
to use them</strong></em>. To date, there have been three such paradigms and there are
unlikely to be any others. </p>
<h2 id="paradigm-overview"><a class="header" href="#paradigm-overview">Paradigm overview</a></h2>
<p>The three paradigms included in this overview are <strong>Structured</strong>, <strong>Object
oriented</strong> and <strong>Functional.</strong></p>
<h3 id="structured"><a class="header" href="#structured">Structured</a></h3>
<p>The first one to be adopted (but no the first to be invented) was structured
programming, discovered by Dijkstra. He showed that the use of unrestrained
jumps (<code>goto</code> statements) is harmful to program structure so he replaced those
jumps with the more familiars <code>if/then/else</code> and <code>do/while/until</code> constructs.</p>
<p><em>Structured programming imposes discipline on direct transfer of control</em></p>
<h3 id="object-oriented"><a class="header" href="#object-oriented">Object Oriented</a></h3>
<p>Two years earlier Object oriented programming was discovered by Ole and Kristen.
These two programmer noticed that the function call stack frame in the <code>ALGOL</code>
language could be moved to a heap, thereby allowing local variables declared by
a function to exist long after the function returned. The function become a
constructors for a class, the local variables became instance variables, and the
nested functions became methods. This lead inevitably to the discovery of
polymorphism through the disciplined use of function pointers.</p>
<p><em>Object-oriented programming imposes discipline on indirect transfer of control</em></p>
<h3 id="functional"><a class="header" href="#functional">Functional</a></h3>
<p>The first to be invented was functional programming. Its  invention predates
computer programming itself. Derived from 1-Calculus, its main foundational
notions is immutability -- that is, the notion that the values of symbols do not
change. </p>
<p><em>Functional programming imposes discipline upon assignment</em></p>
<h3 id="food-for-thought"><a class="header" href="#food-for-thought">Food for thought</a></h3>
<p>Notice the pattern that I've quite deliberately set up in introducing these
three programming paradigms: Each of them removes capabilities from the
programmer. None of them adds new capabilities. Each imposes some kind of extra
discipline that is negative in its intent. The paradigms tell us what not to do,
more than they tell us what to do.</p>
<p>Every paradigm takes aways something. The three paradigms together remove <code>goto</code>
statements, functions pointers, and assignment. Is there anything left to take
away ? These were discovered in the span of 10 years, in the many decades that
have followed, no new paradigms have been added.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>What does this has to do with architecture ? We use polymorphism as the
mechanism to cross architectural boundaries; we use functional programming to
impose discipline on the locations of and access to data; and we use structured
programming as the algorithmic foundation of our models. Notice how well those
thee align with the three big concerns of architecture function, separation of
components, and data management.</p>
<h2 id="structured-programming"><a class="header" href="#structured-programming">Structured Programming</a></h2>
<p>Dijkstra realized that programming is hard and that programmer don't do it very
well. A program of any complexity contains too many details for a human brain to
manage without help.  To solve this issue, Dijkstra tried to apply the
mathematical discipline of proof. His vision was the construction of Euclidean
hierarchy of postulates, theorems, corollaries, and lemmas. Programmer would use
proven structures, and tie them together with code that they would prove correct
themselves. He discovered that certain uses of <code>goto</code> statements prevent modules
from being decomposed recursively into smaller units therefore preventing the
use of the divide-and-conquer approach necessary for reasonable proofs. However,
other uses of goto didn't have this problem. He realized that this <em>good</em> uses
of <code>goto</code> corresponds to simple selection and iteration control structures. All
programs can be constructed with three structures: Sequence, Selection and
Iteration. This very same structures made a program provable.</p>
<p>The Euclidean hierarchy of theorems was never built. And programmers never saw
the benefits of working through the laborious process of formally proving each
and every little function correct. Of course, formal, Euclidean style,
mathematical proofs is not the only strategy for proving something correct.
Another highly successful strategy is the scientific method. Proving thins
incorrect. That's the nature of scientific theories and laws: They are
falsifiable but not provable. Science work by proving statement false, not true.
We take as true the statements that, after a long time, we couldn't prove true. </p>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<p>Dijkstra once said: <em>&quot;Testing shows the presence, not the absence, of bugs&quot;.</em>
Functions can be proven to be incorrect with a test, but it can't be proven
correct.  Software development is not like mathematical endeavor, even though is
it seems to manipulate mathematical constructs. Rather, software is like
science. We show correctness by failing in proving incorrectness.</p>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p>In conclusion, structured programming is this ability to create falsifiable
units of programming that makes structured programming valuable today.  At the
architecture level, this is why we still consider functional decomposition to be
on of our best practices. </p>
<h2 id="object-oriented-programming"><a class="header" href="#object-oriented-programming">Object Oriented Programming</a></h2>
<p>The basis of a good architecture is the correct understanding and application of
the principles of Object-oriented design (OO) OO Design is the combination of
data and function but is also explain as &quot;A way to model the real world&quot;.  The
three magic word to explain OO are encapsulation, inheritance and polymorphism.</p>
<h3 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h3>
<p>The encapsulation of data and functions lets us draw a line and bound these
together but the idea is certainly not unique to OO. Indeed, we had perfect
encapsulation in C. Perfect encapsulation in a non-OO language.  C#, Java and
some OO language it's imposible to separate the declaration and definition of a
class. Therefore they abolished the header/implementation like pure <code>C</code> ,where
you would have a <code>library.h</code>, weakening encapsulation.  For these reasons it is
difficult to accept that OO depends on strong encapsulation. In fact, many OO
languages have little or no enforced encapsulation at also.</p>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Inheritance is simply the redeclaration of a group of variables and functions
within an enclosing scope. We could do this with C long time ago or at least we
had a trick, but it's not inheritance per se. Moreover, multiple inheritance is
considerably more difficult to achieve with such trickery.  It's fair to say
that while OO did not give us something completely brand new, it did make the
masquerading of data structures significantly more convenient.</p>
<h3 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h3>
<p>We did have polymorphism in languages before OO. For example in the <code>getchard()</code>
and <code>putchar()</code> which read and write from the STDIN and STDOUT.  The UNIX
operating system requires that every IO devices drivers provide five standard
functions: <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code> and <code>seek</code> and <code>seek</code>. The
signatures of these functions must be identical for every IO driver The bottom
line is that polymorphism is an application of pointers to functions.
Programmers have been using these to achieve polymorphic behavior since 1940s.
In other word, OO has provide nothing new.</p>
<p>The problem with pointers to functions is that they are dangerous. Such use is
driven by a set of manual conventions. If any programmer fails to remember these
conventions, the resulting bug can be hard to track down and eliminate.  OO
languages eliminate these conventions and, therefore, these dangers. Using OO
languages, polymorphism is trivial. That fat provides enormous power that old C
programmer could only dream of. On this basis, we can conclude that OO imposes
discipline on indirect transfer of control. </p>
<h3 id="the-power-of-polymorphism"><a class="header" href="#the-power-of-polymorphism">The power of polymorphism</a></h3>
<p>The power of polymorphism lays on the fact that by implementing functions in,
for example, UNIX IO drivers, then we can assure that the program that use those
functions does not depend on the source code of those &quot;not-dependencies&quot; (IO
Drivers.) In short IO drivers have become plugins to out program. The
plug-in architecture has been interested to achieve IO devices independence,
and has been implemented in almost every operating system since its
introduction.  OO allows the plug-in architecture to be used anywhere, for
anything.</p>
<h3 id="dependency-inversion"><a class="header" href="#dependency-inversion">Dependency Inversion</a></h3>
<p>Before a safe and convenient mechanism for polymorphism was available, <code>Flow control</code> and <code>Source Code Dependency</code> followed the same path. In the typical
calling tree, main functions called high-level functions, mid-level functions,
which called low-level functions.  In this scenario the flow of control was
dictated by the behavior of the dependencies and the dependencies were dictated
by that flow control.  When polymorphism brought into play, something very
different can happen.</p>
<p><img src="../img/dependency_inversion.png" alt="di" /></p>
<p>In <code>Figure 1</code> we can see the classical approach where Flow of control goes on
the same direction as the dependency. <code>Figure 2</code>, shows us how <em>Object A</em> a
high-level function calls a functions in <em>Object B</em> a middle-level function.
The fact that it calls this function through the interface is a source code
contrivance. At runtime, the interface doesn't exist. <em>Object A</em> simply calls
the function within <em>Object B</em> Notice that here the flow of control still goes
from <em>Object A</em> the high-level function to the low-level function <em>Object B</em>.
The fact that OO languages provide safe and convenient polymorphism means that
any source code dependency, no matter where it is, can be inverted by inserting
an interface between them. That's the power that OO provides. That's what OO is
really all about- at least from an architect point of view.  As an example, you
can rearrange the source doe dependencies of your system so that the database
and the user interface (UI) depend on the business rules rather than the other
way around.  This means that the Database and de UI can be plugins to the
business rules. This means that the business rules never mentions the UI or the
Database.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>OO is the ability, through the use of polymorphism, to gain absolute control
over every source code dependency in the system. It allows the architect to
create a plug-in architecture, in which modules that contain high-level policies
are independent of module that contain los-level details. The low-level details
are relegated to plug-in modules that can be deployed and developed
independently from the modules that contain high-level policies.</p>
<h1 id="part-iii-design-principles"><a class="header" href="#part-iii-design-principles">Part III: Design Principles</a></h1>
<p>The SOLID principles tell us how to arrange our functions and data structures
into classes, and how those classes should be interconnected. A class is simply
a coupled grouping of functions and data. Every software system has such
groupings, Wether they are called classes or not. The SOLID principles apply to
those groupings.</p>
<h2 id="solid"><a class="header" href="#solid">S.O.L.I.D</a></h2>
<p>The goal of the principles is the creation of mid-level software structures
that:</p>
<ul>
<li>Tolerate change</li>
<li>Are easy to understand</li>
<li>Are the basis of components than can be used in many software systems</li>
</ul>
<h2 id="single-responsibility-principle-srp"><a class="header" href="#single-responsibility-principle-srp">Single responsibility principle (SRP)</a></h2>
<p>Of all of the SOLID principles, the SRP might be the least understood and it
might be due to its name. It is too easy for programmers to hear the name and
then assume that it means that every module should do just one thing.  Make no
mistake, there is a principle like that. A <strong>function</strong> should do one, and only
one, thing. We use that principle when we are refactoring large functions into
smaller functions; we use it at the lowest levels. But it is now one of the
SOLID principles-- it is not SRP.</p>
<p>A module should be responsible for one and only one actor (An actor being a
group of users or stakeholders that will be likely to request changes to the
system).</p>
<p>Now, what do we mean by the word &quot;module&quot; ? The simplest definition is just a
source file. Most of the time that definition works fine. Some languages and
development environments, though, don't use source files to contain their code.
In those cases a module is just a cohesive set of functions and data structures.</p>
<p>[SEE THE EXAMPLE OF THE EMPLOYEE ON THE BOOK]</p>
<p>To conclude, the single responsibility principle is about functions and classes
but it appears in a different form at two more levels. At the level of
components, it becomes the Common Clausure Principle. At the architectural
level, it becomes the Axis of change responsible for the creation of
Architectural Boundaries.</p>
<h2 id="the-open-closed-principle-ocp"><a class="header" href="#the-open-closed-principle-ocp">The open-closed principle (OCP)</a></h2>
<p>A software should be open for extension but closed for modification In other
words, the behaviour of a software artifact ought to be extendible, without
having to modify that artifact. And this is the most fundamental reason that we
study software architecture. A good software architecture would reduce the
amount of changed code to the barest minimum. Ideally, zero.  How?  By properly
separating the things that change for different reasons (SRP) and then
organizing the dependencies between them (DIP).</p>
<p>Bellow we see an image that's fully explained on the book. I suggest reviewing
this example in particularly.</p>
<p><img src="../img/financial_ocp.png" alt="financial ocp" /></p>
<p>If component A should be protected from changes in component B, then B depends
on A. We wan the <em>Controller</em> to be protected from changes in the <em>Presenters</em>.
We want to protect the <em>Presenters</em> from changes in the views. WE wan to protect
the <em>Interactor</em> from changes in-- well, everything.  Why should the
<em>Interactor</em> hold such a privilege position ? Because it contains the business
rules, it contains the higher level policies of the application.  This is how
OCP works at the architectural level. Architects separate functionality based on
how, why, and when it changes, and then organize that separated functionality
into a hierarchy of components. Higher-level components or protected from
changes made to the lower-level components.</p>
<p>OCP is the one driving forces behind the architecture of systems. The goal to
make te system easy to extend without incurring a high impact of change. This
goal is accomplished by partitioning the system into components, and arranging
from changes in lower-level components. </p>
<h2 id="the-liskov-substitution-principle-lsp"><a class="header" href="#the-liskov-substitution-principle-lsp">The Liskov substitution principle (LSP)</a></h2>
<p>Substitutability is a principle in object-oriented programming stating that, in
a computer program, if S is a subtype of T, then objects of type T may be
replaced with objects of type S without altering any of the desirable properties
of the program.</p>
<h3 id="lsp-and-architecture"><a class="header" href="#lsp-and-architecture">LSP and architecture</a></h3>
<p>In the earlier ages of OO we thought LSP as a way to guide the use of
inheritance, as shown in the previous sections. However, over the years the LSP
has morphed into a broader principle of software design that pertains to
interface and implementations. We could have several Ruby clases that implement
the same interface or we might have a set of services that all respond to the
same REST interface.  In all of these situations, and more, the LSP is
applicable because there are users who depend on well-defined interfaces. In
conclusion, the LSP can, and should, be extended to the level of architecture.
A simple violation of substitutability, can cause a system's architecture to be
polluted with significant amount of extra mechanisms.</p>
<h2 id="the-interface-segregation-principle-isp"><a class="header" href="#the-interface-segregation-principle-isp">The interface segregation principle (ISP)</a></h2>
<p>The interface-segregation principle (ISP) states that no client should be forced
to depend on methods it does not use. In general is harmful to depend on modules
that contain more than you need. This is obviously true for source code
dependencies that can force unnecessary recompilation and redeployment-- but it
is also true at a much higher, architectural level.</p>
<h2 id="the--dependency-inversion-principle-dip"><a class="header" href="#the--dependency-inversion-principle-dip">The  dependency inversion principle (DIP)</a></h2>
<p>The dependency inversion principle (DIP) tells us that the most flexible systems
are those in which source code dependencies refer only to abstractions, not to
congregations.  It is the volatile concrete elements of our system that we want
to avoid depending on. Those are the modules  that we are actively developing,
and that are undergoing frequent change. Interfaces are less volatile that
implementations. This implications boils down to a set of very specific coding
practices: </p>
<ul>
<li>Don't refer to volatile concrete classes. Refer to abstract interfaces
instead.</li>
<li>Don't derive from volatile concrete classes.</li>
<li>Don't override concrete functions. Concrete functions often require source
code when you override those functions, you do not eliminate those
dependencies-- indeed you inherit them.</li>
<li>Never mentions the name of anything concrete and volatile.</li>
</ul>
<h3 id="factories-this-is-the-posta-dd"><a class="header" href="#factories-this-is-the-posta-dd">Factories this is the posta dd</a></h3>
<p>To comply to these rules, the creation of volatile concrete objects requires
special handling. The Factory pattern is a creational patter that defines an
Interface for creating an object and defers instantiation until runtime. It is
commonly used when you don't know how many or what type of objects will be
needed until during runtime.</p>
<h1 id="part-iv--components-principles"><a class="header" href="#part-iv--components-principles">Part IV:  Components principles</a></h1>
<p>If SOLID principles tell us how to arrange the bricks into walls and rooms, then
the component principles tell us how to arrange the rooms into buildings.</p>
<h2 id="components-the-smallest-entities-that-can-be-deployed-as-a-single-unit"><a class="header" href="#components-the-smallest-entities-that-can-be-deployed-as-a-single-unit">Components The smallest entities that can be deployed as a single unit.</a></h2>
<p>Examples - jar file, DLL, shared library, etc.</p>
<p>They can be combined into single binaries or kept separate as plugins to other
binaries.  Whatever the use-case, good components always retain the ability to
be independently deployable and, hence, independently developable.</p>
<h2 id="component-cohesion"><a class="header" href="#component-cohesion">Component cohesion</a></h2>
<p>There are three principles of component cohesion.</p>
<ul>
<li>REP:  The Reuse/Release equivalence principle</li>
<li>CCP:  The Common Closure Principle</li>
<li>CRP:  The Common Reuse Principle</li>
</ul>
<h3 id="the-reuserelease-equivalence-principle"><a class="header" href="#the-reuserelease-equivalence-principle">The reuse/release equivalence principle</a></h3>
<p><strong>The granule of reuse is the granule of release</strong> </p>
<p>We are now living in the age of software reuse -- a fulfillment of one of the
oldest promises of the object-oriented model.  From a software design and
architecture point of view, this principle means that the classes and modules
that are formed into a component must belong to a cohesive group classes and
modules that are grouped together into a component should be releasable together
though it is hard to precisely explain the glue that holds these together into a
single component. </p>
<p>The weakness of this principle is more than compensated by the strength of next
two principle strongly define this principle in the negative sense.</p>
<h3 id="the-common-closure-principle"><a class="header" href="#the-common-closure-principle">The common closure principle</a></h3>
<p><strong>Gather into component those classes that change for the same reasons and at
the same times. Separate into different components those classes that change at
different times and for different reasons</strong></p>
<p>The CCP basically says that a component should not have multiple reasons to
change. For most application, maintainability is more important than
reusability. If the code in an application must change, you would like all of
the changes to occur in one single component. </p>
<h4 id="similarity-with-srp-the-ccp-is-the-component-form-of-the-srp-the-srp-tells"><a class="header" href="#similarity-with-srp-the-ccp-is-the-component-form-of-the-srp-the-srp-tells">Similarity with SRP The CCP is the component form of the SRP. The SRP tells</a></h4>
<p>us to separate methods into different classes, if they change for different
reasons. The CCP tells us to separate classes into different components, if they
change for different reasons.</p>
<h3 id="the-common-reuse-principle"><a class="header" href="#the-common-reuse-principle">The common reuse principle.</a></h3>
<p><strong>Don't force users of a component to depend on things they don't need.</strong></p>
<p>The CRP is yet another principle that helps us to decide which classes and
modules should be placed into a component. </p>
<p>We want to make sure that classes that we put together into a component are
inseparable--  that it is impossible to depend on some and not on the others.
Otherwise, we will be redeploying more components than is necessary, and wasting
significant effort.</p>
<h4 id="relation-to-isp"><a class="header" href="#relation-to-isp">Relation to ISP.</a></h4>
<p>The CRP is the generic version of the ISP. The ISP advises us not to depend on
classes that have methods we don't use. The CRP advises us not to depend on
components that have classes we don't use. </p>
<h3 id="the-tension-diagram-for-component-cohesion"><a class="header" href="#the-tension-diagram-for-component-cohesion">The tension diagram for component cohesion</a></h3>
<p>The REP and CCP are inclusive principles: Both tend to make components larger.
The CRP is an exclusive principle, driving components to be smaller. It is the
tension between these principles that good architects seek to resolve. </p>
<p><img src="../img/CohesionPrinciplesTensionDiagram.jpg" alt="Tensions Cohesion Diagram " /></p>
<p>An architect who focuses on just the REP and CRP will find that too many
component are impacted when simple changes are made.. In contrast, and architect
who focuses too strongly on the CCP and REP will cause too many unneeded
releases to be generated.</p>
<p>Generally projects tend to start on the right hand of the triangle, where the
only sacrifice is reuse. As the project matures, and other projects begin to
draw from it, the project will slide over to the left.  It has more to do with
the way that project is developed and used than with what the project actually
does.</p>
<p>Moreover, the balance is almost always dynamic. That is the partitioning that is
appropriate today might not be  appropriate next year.</p>
<h2 id="component-coupling"><a class="header" href="#component-coupling">Component Coupling</a></h2>
<h3 id="the-acyclic-dependencies-principle"><a class="header" href="#the-acyclic-dependencies-principle">The Acyclic dependencies principle</a></h3>
<p><em>Allow no cycles in the component dependency graph</em></p>
<p>Have you ever worked all day, then go home, only to arrive the next morning to
find that your stuff no longer works ? This is because someone stayed later than
you and changes something you depend on! I call this &quot;The morning after
syndrome&quot;</p>
<p>Over the last two decades only two solutions to this problem have evolved. The
first is the &quot;Weekly build&quot; and &quot;The Acyclic dependency principle&quot;</p>
<h4 id="the-weekly-build"><a class="header" href="#the-weekly-build">The weekly build</a></h4>
<p>Used to be common in medium-sized projects. It works like this: All the
developers ignore each other the first four days of the week. Then, on Friday,
they integrate all their changes and build the system.  Unfortunately, as the
project grows, it becomes less feasible to finish integrating the project on
Friday since the integration time increase with the project size.</p>
<h4 id="eliminating-dependency-cycles"><a class="header" href="#eliminating-dependency-cycles">Eliminating dependency cycles</a></h4>
<p>The solution to this is to partition the development environment into releasable
components. The components become units of work that can be the responsibility
of a single developer, or a team of developers. Releases are donde by components
now. Changes made to one component do not need to have an immediate affect on
other teams. Each team can decide for itself when to adapt its own components to
new releases of the components. Moreover, integration happens in small
increments.  For this strategy to work, there can be no cycles in the component
dependency graph. It's a DAG (Directed Acyclic Graph).  Whenever we find a
cyclic on the dependency graph (as seen in the figure between Entities and
Authorizer) we should make sure to remove it.  <img src="../img/DependencyGraph.jpg" alt="Dependency Graph" /> To break the cycle we can take two
approaches.</p>
<ol>
<li>
<p>Apply the Dependency Inversion Principle (DIP). So we can make Authorizer
depend on Entities and not the other way around.  <img src="../img/DependencyGraphDIP.jpeg" alt="DIP for Dependency Cycle" /></p>
</li>
<li>
<p>Create a new component that both Authorizer and Entities depend on.  <img src="../img/DependencyGraphNewComponent.jpeg" alt="New Component for Dependency Cycle" /></p>
</li>
</ol>
<h3 id="top-down-design-the-component-dependency-graph-structure-cannot-be-designed"><a class="header" href="#top-down-design-the-component-dependency-graph-structure-cannot-be-designed">TOP-DOWN Design The component dependency graph structure cannot be designed</a></h3>
<p>from the top down. It is not one of the first things about the system that is
designed, but rather evolves as the system grows and changes.  In fact, the
component dependency diagrams have very little to do with describing the
function of the application. Instead, they are a map to the buildability and
maintainability of the application. If there's no software to build or maintain,
then, there's no need for such diagram.</p>
<h3 id="the-stable-dependencies-principle"><a class="header" href="#the-stable-dependencies-principle">The stable dependencies principle</a></h3>
<p><em>Depend in the direction of stability</em></p>
<p>Design cannot be completely static. Some volatility is necessary if the design
is to be maintain. By conforming to the <strong>Common closure principle (CCP)</strong>, we
create component that are sensitive to certain kinds of changes bu immune to
others.  By conforming to the <strong>Stable dependencies principle (SDP)</strong> we ensure
that module that are intended to be easy to change are not depended on by
modules that are harder to change.</p>
<h3 id="stability"><a class="header" href="#stability">Stability</a></h3>
<p>Stability is related to the amount of work required to make a change. One way to
make a software component difficult to change, is to make lots of other software
depend on it. The way we measure this stability is by counting the number of
dependencies that enter and leave that component.</p>
<p><strong>Fan-in:</strong> Incoming dependencies <strong>Fan-out:</strong> Outgoing dependencies
<strong>I(Instability):</strong> Fan-in / (Fan-in+ Fan-out)</p>
<p>Not all components should be stable, if all components in a system were
maximally stable, the system would be unchangeable. We wan to design system with
components that are stable and components that are unstable. </p>
<h3 id="the-stable-abstraction-principle-a-component-should-be-as-abstract-as-it-is-stable"><a class="header" href="#the-stable-abstraction-principle-a-component-should-be-as-abstract-as-it-is-stable">The stable abstraction principle <em>A component should be as abstract as it is stable</em></a></h3>
<p>Software that encapsulates hight level policies should go in stable components
while unstable components should contain volatile software. The answer is found
in the OCP. This principle tells us that it is possible and desirable to
create classes that are flexible enough to be extended without requiring
modification. Which kind of classes conform to this principle? Abstract
classes.</p>
<p>The Stable Abstractions Principle (SAP) sets up a relationship between stability
and abstractness. On the one hand, it says that a stable component should also
be abstract so that its stability does not prevent it from being extended. On
the other hand, it says that an unstable component should be concrete since it
its instability allows the concrete code within it to be easily changed. It
should consist of interfaces and abstract classes so that it can be extended.</p>
<p>The SAP and the SDP combined amount to the DIP for components. This is true
because the SDP says that dependencies should run in the direction of stability,
and the SAP says that stability implies abstraction. Thus dependencies run in
the direction of abstraction </p>
<h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>First if all, a software architect is a programmer; and continues to be a
programmer. Never fall into the lie that a software architect is not a
programmer.  The architecture of a software system is the shape given to that
system by those who build it. The form of that shape is in the division of that
system into components, the arrangement of those components, and the ways in
which those components communicate with each other.</p>
<p><em>The strategy behind that facilitation is to leave as many options open as
possible, for as long as possible</em></p>
<p>The primary goal of architecture is to preserve the life cycle of the system.
Te ultimate goal is to minimize the lifetime cost of the system and to maximize
programmer productivity.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>A group of 5 developers can quite effectively work together to develop a
monolithic system without well-defined components or interfaces, on the other
hand, a system developed by 5 different teams can not make progress unless the
system is divided into well define components.</p>
<p>Such a component-per-team architecture is not likely to be the best architecture
for deployment, operation, and maintenance of the system.  Nevertheless, it is
the architecture that a group of team will gravitate toward if they are
driven solely by development schedule.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>A goal of software architecture should be to make a system that can be easily
deployed with a single action.  Unfortunately, deployment strategy is seldom
considered during initial development. This leads to system very easy to deploy
but very difficult to develop.</p>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<p>The impact of architect on system operation tends to be les dramatic than the
impact of architecture on development, deployment, and maintenance. Almost any
operational difficulty can be resolved by throwing more hardware at the system
without drastically impacting software architecture.  Architecture should reveal
operation. The architecture of the system should elevate the use cases, the
visible landmark for the developers. This simplifies the understanding of the
system and, therefore, greatly aids in development and maintenance.</p>
<h2 id="maintenance-the-never-ending-parade-of-new-features-and-the-inevitable-trail"><a class="header" href="#maintenance-the-never-ending-parade-of-new-features-and-the-inevitable-trail">Maintenance The never-ending parade of new features and the inevitable trail</a></h2>
<p>of defects and corrections consume vast amounts of human resources.  The primary
cost of maintenance is in spelunking and risk. Spelunking is the cost of digging
through the existing software, trying to determine the best place and the best
strategy to add a new feature or to repair a defect. While making such changes,
the likelihood of creating inadvertent defects is always there, adding to the
cost of risk.</p>
<h2 id="keeping-option-open-as-we-described-in-an-earlier-chapter-software-has-two"><a class="header" href="#keeping-option-open-as-we-described-in-an-earlier-chapter-software-has-two">Keeping option open As we described in an earlier chapter, software has two</a></h2>
<p>types of value: the value of its behavior and the value of its structure. The
second of these is the greater of the two because it is this value that makes
software soft.</p>
<p>All software systems can be decomposed into two major elements: policy and
details. The policy element embodies all the business rules and procedures. The
policy is where the true value of the system lives.</p>
<p>The details are those things that are necessary to enable humans, other systems,
and programmers to communicate with the policy, but that do not impact the
behavior of the policy at all. They include IO devices, databases, web systems,
servers, frameworks, communication protocols, and so forth. </p>
<p>The goal of the architect is to create a shape for the system that recognizes
policy as the most essential element of the system while making the details
irrelevant to that policy.</p>
<p>• It is not necessary to choose a database system in the early days of
development, because the high-level policy should not care which kind of
database will be used. Indeed, if the architect is careful, the high-level
policy will not care if the database is relational, distributed, hierarchical,
or just plain flat files.</p>
<p>• It is not necessary to choose a web server early in development, because the
high-level policy should not know that it is being delivered over the web. If
the high-level policy is unaware of HTML, AJAX, JSP, JSF, or any of the rest of
the alphabet soup of web development, then you don't need to decide which web
system to use until much later in the project. Indeed, you don't even have to
decide if the system will be delivered over the web. </p>
<p>• It is not necessary to adopt REST early in development, because the high-
level policy should be agnostic about the interface to the outside world.  Nor
is it necessary to adopt a micro-services framework, or a SOA framework. Again,
the high-level policy should not care about these things.</p>
<p>• It is not necessary to adopt a dependency injection framework early in
development, because the high-level policy should not care how dependencies are
resolved.  <em>A good architect pretends that the desicion has not been made and,
and shapes the system such that those desision can still be deferred or changed
for as long time as possible.</em></p>
<p><em>A good architect maximize the number of decisions not made</em></p>
<h2 id="conclusion-good-architects-carefully-separate-details-from-policy-and-then"><a class="header" href="#conclusion-good-architects-carefully-separate-details-from-policy-and-then">Conclusion Good architects carefully separate details from policy, and then</a></h2>
<p>decouple the policy from the details so thoroughly that the policy has no
knowledge of the details and does not depend on the details in any way. Good
architects design the policy so that decisions about the details can be delayed
and deferred as long as possible.</p>
<h1 id="independence"><a class="header" href="#independence">Independence</a></h1>
<p>(<em>I think this chapter is very important so most of it won't be a summary but an
exact copy</em>)</p>
<h2 id="use-cases-the-first-bulletuse-casesmeans-that-the-architecture-of-the"><a class="header" href="#use-cases-the-first-bulletuse-casesmeans-that-the-architecture-of-the">Use Cases The first bullet—use cases—means that the architecture of the</a></h2>
<p>system must support the intent of the system. If the system is a shopping cart
application, then the architecture must support shopping cart use cases.
Indeed, this is the first concern of the architect, and the first priority of
the architecture. The architecture must support the use cases. </p>
<p>However, as we discussed previously, architecture does not wield much influence
over the behavior of the system. There are very few behavioral options that the
architecture can leave open. But influence isn't everything. The most important
thing a good architecture can do to support behavior is to clarify and expose
that behavior so that the intent of the system is visible at the architectural
level.</p>
<p>A shopping cart application with a good architecture will look like a shopping
cart application. The use cases of that system will be plainly visible within
the structure of that system. Developers will not have to hunt for behaviors,
because those behaviors will be first-class elements visible at the top level of
the system. Those elements will be classes or functions or modules that have
prominent positions within the architecture, and they will have names that
clearly describe their function. </p>
<h2 id="operation-1"><a class="header" href="#operation-1">Operation</a></h2>
<p>Architecture plays a more substantial, and less cosmetic, role in supporting the
operation of the system. If the system must support 100,000 customers per
second, the architecture must support that.</p>
<p>For some systems, this will mean arranging the processing elements of the system
into an array of little services can be run in parallel on many different
servers. For other systems, it will mean a plethora of little lightweight
threads sharing the address space of a single process within a single processor.
Still other systems will need just a few processes running in isolated address
spaces. And some systems can even survive as simple monolithic programs running
in a single process. </p>
<p>As strange as it may seem, this decision is one of the options that a good
architect leaves open. A system that is written as a monolith, and that depends
on that monolithic structure, cannot easily be upgraded to multiple processes,
multiple threads, or micro-services should the need arise. By comparison, an
architecture that maintains the proper isolation of its components, and does not
assume the means of communication between those components, will be much easier
to transition through the spectrum of threads, processes, and services as the
operational needs of the system change over time.</p>
<h2 id="development-1"><a class="header" href="#development-1">Development</a></h2>
<p>Architecture plays  a significant role in supporting the development
environment.  Conway's law come into play here:</p>
<p><em>Any organization that designs a system will produce a design whose structure is
a copy of the organization's communication structure.</em></p>
<h2 id="deployment-1"><a class="header" href="#deployment-1">Deployment</a></h2>
<p>The goal is “immediate deployment.&quot; A good architecture does not rely on dozens
of little configuration scripts and property file tweaks. It does not require
manual creation of directories or files that must be arranged just so. A good
architecture helps the system to be immediately deployable after build.</p>
<h2 id="leaving-options-open"><a class="header" href="#leaving-options-open">Leaving options open</a></h2>
<p>A good architecture balances all of these concerns with a component structure
that mutually satisfies them all. Sounds easy, right? Well, it's easy for me to
write that. The reality is that achieving this balance is pretty hard. The
problem is that most of the time we don't know what all the use cases are, nor
do we know the operational constraints, the team structure, or the deployment
requirements. Worse, even if we did know them, they will inevitably change
as the system moves through its life cycle. In short, the goals we must meet
are indistinct and inconstant. Welcome to the real world. </p>
<p>A good architecture makes the system easy to change, in all the ways that it
must change, by leaving options open.</p>
<h2 id="decoupling-layers"><a class="header" href="#decoupling-layers">Decoupling Layers</a></h2>
<p>Consider the use cases. The architect wants the structure of the system to
support all the necessary use cases, but does not know what all those use cases
are. However, the architect does know the basic intent of the system. It's a
shopping cart system, or it's a bill of materials system, or it's an order
processing system. So the architect can employ the Single Responsibility
Principle and the Common Closure Principle to separate those things that change
for different reasons, and to collect those things that change for the same
reasons—given the context of the intent of the system. </p>
<p>What changes for different reasons? There are some obvious things. User
interfaces change for reasons that have nothing to do with business rules. Use
cases have elements of both. Clearly, then, a good architect will want to
separate the UI portions of a use case from the business rule portions in such a
way that they can be changed independently of each other, while keeping those
use cases visible and clear. </p>
<p>Business rules themselves may be closely tied to the application, or they may be
more general. For example, the validation of input fields is a business rule
that is closely tied to the application itself. In contrast, the calculation of
interest on an account and the counting of inventory are business rules that are
more closely associated with the domain. These two different kinds of rules will
change at different rates, and for different reasons—so they should be separated
so that they can be independently changed.</p>
<p>The database, the query language, and even the schema are technical details that
have nothing to do with the business rules or the UI. They will change at rates,
and for reasons, that are independent of other aspects of the system.
Consequently, the architecture should separate them from the rest of the system
so that they can be independently changed.</p>
<p>Thus we find the system divided into decoupled horizontal layers—the UI,
application-specific business rules, application-independent business rules, and
the database, just to mention a few.</p>
<h2 id="decoupling-use-cases"><a class="header" href="#decoupling-use-cases">Decoupling Use Cases</a></h2>
<p>What else changes for different reasons? The use cases themselves! The use case
for adding an order to an order entry system almost certainly will change at a
different rate, and for different reasons, than the use case that deletes an
order from the system. Use cases are a very natural way to divide the
system.</p>
<p>At the same time, use cases are narrow vertical slices that cut through the
horizontal layers of the system. Each use case uses some UI, some
application-specific business rules, some application-independent business
rules, and some database functionality. Thus, as we are dividing the system in
to horizontal layers, we are also dividing the system into thin vertical use
cases that cut through those layers.</p>
<p>To achieve this decoupling, we separate the UI of the add-order use case from
the UI of the delete-order use case. We do the same with the business rules, and
with the database. We keep the use cases separate down the vertical height of
the system.</p>
<p>You can see the pattern here. If you decouple the elements of the system that
change for different reasons, then you can continue to add new use cases without
interfering with old ones. If you also group the UI and database in support of
those use cases, so that each use case uses a different aspect of the UI and
database, then adding new use cases will be unlikely to affect older ones.</p>
<h2 id="decoupling-mode"><a class="header" href="#decoupling-mode">Decoupling mode</a></h2>
<p>Now think of what all that decoupling means for the second bullet: operations.
If the different aspects of the use cases are separated, then those that must
run at a high throughput are likely already separated from those that must run
at a low throughput. If the UI and the database have been separated from the
business rules, then they can run in different servers. Those that require
higher bandwidth can be replicated in many servers.</p>
<p>In short, the decoupling that we did for the sake of the use cases also helps
with operations. However, to take advantage of the operational benefit, the
decoupling must have the appropriate mode. To run in separate servers, the
separated components cannot depend on being together in the same address space
of a processor. They must be independent services, which communicate over a
network of some kind.</p>
<p>Many architects call such components “services&quot; or “micro-services,&quot; depending
upon some vague notion of line count. Indeed, an architecture based on services
is often called a service-oriented architecture. If that nomenclature set off
some alarm bells in your mind, don't worry. I'm not going to tell you that SoA
is the best possible architecture, or that microservices are the wave of the
future. The point being made here is that sometimes we have to separate our
components all the way to the service level. Remember, a good architecture
leaves options open. The decoupling mode is one of those options.</p>
<p>Before we explore that topic further, let's look to the other two bullets.</p>
<p>(<em>Read Independent Develop-Ability and Independent deployability</em>)</p>
<h2 id="duplication"><a class="header" href="#duplication">Duplication</a></h2>
<p>Architects often fall into a trap—a trap that hinges on their fear of
duplication.</p>
<p>Duplication is generally a bad thing in software. We don't like duplicated code.
When code is truly duplicated, we are honor-bound as professionals to reduce and
eliminate it. </p>
<p>But there are different kinds of duplication. There is true duplication, in
which every change to one instance necessitates the same change to every
duplicate of that instance. Then there is false or accidental duplication. If
two apparently duplicated sections of code evolve along different paths—if they
change at different rates, and for different reasons—then they are not true
duplicates. Return to them in a few years, and you'll find that they are very
different from each other. </p>
<p>Now imagine two use cases that have very similar screen structures. The
architects will likely be strongly tempted to share the code for that structure.
But should they? Is that true duplication? Or it is accidental?</p>
<p>Most likely it is accidental. As time goes by, the odds are that those two
screens will diverge and eventually look very different. For this reason, care
must be taken to avoid unifying them. Otherwise, separating them later will be a
challenge.</p>
<p>When you are vertically separating use cases from one another, you will run into
this issue, and your temptation will be to couple the use cases because they
have similar screen structures, or similar algorithms, or similar database
queries and/or schemas. Be careful. Resist the temptation to commit the sin of
knee-jerk elimination of duplication. Make sure the duplication is real.</p>
<p>By the same token, when you are separating layers horizontally, you might notice
that the data structure of a particular database record is very similar to the
data structure of a particular screen view. You may be tempted to simply pass
the database record up to the UI, rather than to create a view model that looks
the same and copy the elements across. Be careful: This duplication is almost
certainly accidental. Creating the separate view model is not a lot of effort,
and it will help you keep the layers properly decoupled.</p>
<h2 id="decoupling-modes-again"><a class="header" href="#decoupling-modes-again">Decoupling Modes (Again)</a></h2>
<p>Back to modes. There are many ways to decouple layers and use cases. They can be
decoupled at the source code level, at the binary code (deployment) level, and
at the execution unit (service) level.</p>
<p>• <strong>Source level</strong>. </p>
<p>We can control the dependencies between source code modules so that changes to
one module do not force changes or recompilation of others (e.g., Ruby Gems).
In this decoupling mode the components all execute in the same address space,
and communicate with each other using simple function calls. There is a single
executable loaded into computer memory. People often call this a monolithic
structure</p>
<p>• <strong>Deployment level</strong>.</p>
<p>We can control the dependencies between deployable units such as jar files,
DLLs, or shared libraries, so that changes to the source code in one module do
not force others to be rebuilt and redeployed. Many of the components may still
live in the same address space, and communicate through function calls. Other
components may live in other processes in the same processor, and communicate
through interprocess communications, sockets, or shared memory. The important
thing here is that the decoupled components are partitioned into independently
deployable units such as jar files, Gem files, or DLLs. </p>
<p>• <strong>Service level</strong>.</p>
<p>We can reduce the dependencies down to the level of data structures, and
communicate solely through network packets such that every execution unit is
entirely independent of source and binary changes to others (e.g., services or
micro-services) </p>
<p>What is the best mode to use? The answer is that it's hard to know which mode is
best during the early phases of a project. Indeed, as the project matures, the
optimal mode may change.</p>
<p>For example, it's not difficult to imagine that a system that runs comfortably
on one server right now might grow to the point where some of its components
ought to run on separate servers. While the system runs on a single server, the
source-level decoupling might be sufficient. Later, however, it might require
decoupling into deployable units, or even services.</p>
<p>One solution (which seems to be popular at the moment) is to simply decouple at
the service level by default. A problem with this approach is that it is
expensive and encourages coarse-grained decoupling. No matter how “micro&quot; the
micro-services get, the decoupling is not likely to be fine-grained enough.</p>
<p><strong>My preference is to push the decoupling to the point where a service could be
formed. should it become necessary; but then to leave the components in the same
address space as long as possible. This leaves the option for a service open.</strong></p>
<p>A good architecture will allow a system to be born as a monolith, deployed in a
single file, but then to grow into a set of independently deployable units, and
then all the way to independent services and/or micro-services. Later, as things
change, it should allow for reversing that progression and sliding all the way
back down into a monolith.</p>
<h1 id="boundaries-drawing-lines"><a class="header" href="#boundaries-drawing-lines">Boundaries: Drawing Lines</a></h1>
<p>Software architecture is the art of drawing lines that I call boundaries. Some
of those lines are drawn very early in a project's life—even before any code is
written. Others are drawn much later. Those that are drawn early are drawn for
the purposes of deferring decisions for as long as possible, and of keeping
those decisions from polluting the core business logic.</p>
<p>Recall that the goal of an architect is to minimize the human resources required
to build and maintain the required system. What it is that saps this kind of
people-power? Coupling—and especially coupling to premature decisions.</p>
<p>Which kinds of decisions are premature? Decisions that have nothing to do with
the business requirements—the use cases—of the system. These include decisions
about frameworks, databases, web servers, utility libraries, dependency
injection, and the like. A good system architecture is one in which decisions
like these are rendered ancillary and deferrable. A good system architecture
does not depend on those decisions. A good system architecture allows those
decisions to be made at the latest possible moment, without significant impact.</p>
<h2 id="which-lines-do-you-draw-and-when-do-you-draw-them"><a class="header" href="#which-lines-do-you-draw-and-when-do-you-draw-them">Which Lines Do You Draw, and When Do You Draw Them?</a></h2>
<p>You draw lines between things that matter and things that don't. The GUI doesn't
matter to the business rules, so there should be a line between them.  The
database doesn't matter to the GUI, so there should be a line between them.  The
database doesn't matter to the business rules, so there should be a line between
them.</p>
<p>The classes and interfaces in this diagram are symbolic. In a real application,
there would be many business rule classes, many database interface classes, and
many database access implementations. All of them, though, would follow roughly
the same pattern.</p>
<p><img src="../img/db_boundaries.png" alt="Database Boundaries" /></p>
<p>Note the two arrows leaving the <em>DatabaseAccess</em> class. Those two arrows point
away from the <em>DatabaseAccess</em> class. That means that none of these classes
knows that the <em>DatabaseAccess</em> class exists.  The <em>BusinessRules</em> do not know
about the Database. This implies that the <em>DatabaseInterface</em> classes live in
the <em>BusinessRules</em> component, while the <em>DatabaseAccess</em> classes live in the
Database component.</p>
<h2 id="plugin-architecture"><a class="header" href="#plugin-architecture">Plugin Architecture</a></h2>
<p>The history history of software development technology is the story of how to
conveniently create plugins to establish a scalable and maintainable system
architecture. The core business rules are kept separate from, and independent
of, those components that are either optional or that can be implemented in many
different forms <img src="../img/plugin_arch.png" alt="Plugin Arq" /> Because the user
interface in this design is considered to be a plugin, we have made it possible
to plug in many different kinds of user interfaces. They could be web based,
client/server based, SOA based, Console based, or based on any other kind of
user interface technology </p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>To draw boundary lines in a software architecture, you first partition the
system into components. Some of those components are core business rules; others
are plugins that contain necessary functions that are not directly related to
the core business. Then you arrange the code in those components such that the
arrows between them point in one direction—toward the core business.</p>
<p>You should recognize this as an application of the Dependency Inversion
Principle and the Stable Abstractions Principle. Dependency arrows are arranged
to point from lower-level details to higher-level abstractions. </p>
<h2 id="boundary-anatomy"><a class="header" href="#boundary-anatomy">Boundary Anatomy</a></h2>
<p>The architecture of a system is defined by a set of software components and the
boundaries that separate them. Those boundaries come in many different forms.
In this chapter we'll look at some of the most common.</p>
<h2 id="boundary-crossing"><a class="header" href="#boundary-crossing">Boundary crossing</a></h2>
<p>At runtime, a boundary crossing is nothing more than a function on one side of
the boundary calling a function on the other side and passing along some data.
The trick to creating an appropriate boundary crossing is to manage the source
code dependencies.</p>
<h2 id="the-dreaded-monolith"><a class="header" href="#the-dreaded-monolith">The dreaded monolith</a></h2>
<p>The simplest and most common of the architectural boundaries has no strict
physical representation. It is simply a disciplined segregation of functions and
data within a single processor and a single address space. In a previous
chapter, I called this the source-level decoupling mode.</p>
<p>The fact that the boundaries are not visible during the deployment of a monolith
does not mean that they are not present and meaningful. Even when statically
linked into a single executable, the ability to independently develop and
marshal the various components for final assembly is immensely valuable. </p>
<p>Such architectures almost always depend on some kind of dynamic polymorphism to
manage their internal dependencies. This is one of the reasons that
object-oriented development has become such an important paradigm in recent
decades.</p>
<p>The simplest possible boundary crossing is a function call from a low-level
client to a higher-level service. Both the runtime dependency and the
compile-time dependency point in the same direction, toward the higher-level
component.</p>
<p>Even in a monolithic, statically linked executable, this kind of disciplined
partitioning can greatly aid the job of developing, testing, and deploying the
project. Teams can work independently of each other on their own components
without treading on each other's toes. High-level components remain independent
of lower-level details.</p>
<p>Communications between components in a monolith are very fast and inexpensive.
They are typically just function calls. Consequently, communications across
source-level decoupled boundaries can be very chatty. Since the deployment of
monoliths usually requires compilation and static linking, components in these
systems are typically delivered as source code.</p>
<h2 id="deployments-components"><a class="header" href="#deployments-components">Deployments components</a></h2>
<p>Deployment does not involve compilation. Instead, the components are delivered
in binary, or some equivalent deployable form. This is the deployment-level
decoupling mode. The act of deployment is simply the gathering of these
deployable units together in some convenient form, such as a WAR file, or even
just a directory.</p>
<p>With that one exception, deployment-level components are the same as monoliths.
The functions generally all exist in the same processor and address space. The
strategies for segregating the components and managing their dependencies are
the same.</p>
<h2 id="threads"><a class="header" href="#threads">Threads</a></h2>
<p>Both monoliths and deployment components can make use of threads. Threads are
not architectural boundaries or units of deployment, but rather a way to
organize the schedule and order of execution. They may be wholly contained
within a component, or spread across many components.</p>
<h2 id="local-processes"><a class="header" href="#local-processes">Local Processes</a></h2>
<p>A much stronger physical architectural boundary is the local process. A local
process is typically created from the command line or an equivalent system call.
Local processes run in the same processor, or in the same set of processors
within a multicore, but run in separate address spaces. Memory protection
generally prevents such processes from sharing memory, although shared memory
partitions are often used.</p>
<p>Most often, local processes communicate with each other using sockets, or some
other kind of operating system communications facility such as mailboxes or
message queues. Each local process may be a statically linked monolith, or it
may be composed of dynamically linked deployment components.</p>
<p>Think of a local process as a kind of uber-component: The process consists of
lower-level components that manage their dependencies through dynamic
polymorphism </p>
<p>Communication across local process boundaries involve operating system calls,
data marshaling and decoding, and interprocess context switches, which are
moderately expensive. Chattiness should be carefully limited</p>
<h2 id="service"><a class="header" href="#service">Service</a></h2>
<p>The strongest boundary is a service. A service is a process, generally started
from the command line or through an equivalent system call. Services do not
depend on their physical location. Communications across service boundaries are
very slow compared to function calls. </p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Most systems, other than monoliths, use more than one boundary strategy. A
system that makes use of service boundaries may also have some local process
boundaries. Indeed, a service is often just a facade for a set of interacting
local processes. A service, or a local process, will almost certainly be either
a monolith composed of source code components or a set of dynamically linked
deployment components.</p>
<p>This means that the boundaries in a system will often be a mixture of local
chatty boundaries and boundaries that are more concerned with latency </p>
<h1 id="policy-and-level"><a class="header" href="#policy-and-level">Policy and Level</a></h1>
<p>Policies that change for different reasons, or at different times, are at
different levels and should be separated into different components.</p>
<p>In a good architecture, the direction of those dependencies is based on the
level of the components that they connect. In every case, low-level components
are designed so that they depend on high-level components.</p>
<p>A strict definition of “level&quot; is “the distance from the inputs and outputs.&quot;
The farther a policy is from both the inputs and the outputs of the system, the
higher its level.</p>
<h1 id="business-rules"><a class="header" href="#business-rules">Business Rules</a></h1>
<p>Strictly speaking, business rules are rules or procedures that make or save the
business money. Very strictly speaking, these rules would make or save the
business money, irrespective of whether they were implemented on a computer.
They would make or save money even if they were executed manually.The fact that
a bank charges N% interest for a loan is a business rule that</p>
<p>We shall call these rules Critical Business Rules, because they are critical to
the business itself, and would exist even if there were no system to automate
them. Critical Business Rules usually require some data to work with. For
example, our loan requires a loan balance, an interest rate, and a payment
schedule. We shall call this data Critical Business Data. This is the data that
would exist even if the system were not automated.The critical rules and
critical data are inextricably bound, so they are a good </p>
<h2 id="entity"><a class="header" href="#entity">Entity</a></h2>
<p>An Entity is an object within our computer system that embodies a small set of
critical business rules operating on Critical Business Data.</p>
<p>You don't need to use an object-oriented language to create an Entity. All that
is required is that you bind the Critical Business Data and the Critical
Business </p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>A use case is a description of the way that an automated system is used. It
specifies the input to be provided by the user, the output to be returned to the
user, and the processing steps involved in producing that output. A use case
describes application-specific business rules as opposed to the Critical
Business Rules within the Entities.</p>
<p>Use cases contain the rules that specify how and when the Critical Business
Rules within the Entities are invoked. Use cases control the dance of the
Entities.</p>
<p>From the use case, it is impossible to tell whether the application is delivered
on the web, or on a thick client, or on a console, or is a pure service.</p>
<p>This is very important. Use cases do not describe how the system appears to the
user. Instead, they describe the application-specific rules that govern the
interaction between the users and the Entities. </p>
<p>A use case is an object. It has one or more functions that implement the
application-specific business rules. </p>
<p>Why are Entities high level and use cases lower level? Because use cases are
specific to a single application and, therefore, are closer to the inputs and
outputs of that system.</p>
<h1 id="screaming-architecture"><a class="header" href="#screaming-architecture">Screaming Architecture</a></h1>
<p>So what does the architecture of your application scream? When you look at the
top-level directory structure, and the source files in the highest-level
package, do they scream “Health Care System,&quot; or “Accounting System,&quot; or
“Inventory Management System&quot;? Or do they scream “Rails,&quot; or “Spring/Hibernate,&quot;
or “ASP&quot;?</p>
<h2 id="the-theme-of-an-architecture"><a class="header" href="#the-theme-of-an-architecture">The Theme of an architecture</a></h2>
<p>Architectures are not (or should not be) about frameworks. Architectures should
not be supplied by frameworks. Frameworks are tools to be used, not
architectures to be conformed to. If your architecture is based on frameworks,</p>
<h2 id="the-purpose-of-an-architecture"><a class="header" href="#the-purpose-of-an-architecture">The purpose of an architecture</a></h2>
<p>Good architectures are centered on use cases so that architects can safely
describe the structures that support those use cases without committing to
frameworks, tools, and environments.</p>
<h2 id="but-what-about-the-web-"><a class="header" href="#but-what-about-the-web-">But what about the web ?</a></h2>
<p>Is the web an architecture? Does the fact that your system is delivered on the
web dictate the architecture of your system? Of course not! The web is a
delivery mechanism—an IO device—and your application architecture should treat
it as such.</p>
<h2 id="frameworks-are-tools-not-ways-of-life"><a class="header" href="#frameworks-are-tools-not-ways-of-life">Frameworks are tools not ways of life</a></h2>
<p>Frameworks can be very powerful and very useful. Framework authors often believe
very deeply in their frameworks. The examples they write for how to use their
frameworks are told from the point of view of a true believer. Other authors who
write about the framework also tend to be disciples of the true belief. They
show you the way to use the framework. Often they assume an all-encompassing,
all-pervading, let-the-framework-do-everything position.</p>
<p>This is not the position you want to take.</p>
<h2 id="testable-architecture"><a class="header" href="#testable-architecture">Testable Architecture</a></h2>
<p>If your system architecture is all about the use cases, and if you have kept
your frameworks at arm's length, then you should be able to unit-test all those
use cases without any of the frameworks in place. You shouldn't need the web
server running to run your tests. You shouldn't need the database connected to
run your tests. </p>
<h1 id="the-clean-architecture"><a class="header" href="#the-clean-architecture">The Clean Architecture</a></h1>
<p>Although these architectures all vary somewhat in their details, they are very
similar. They all have the same objective, which is the separation of concerns.
Each of these architectures produces systems that have the following
characteristics:</p>
<ul>
<li>Independent of frameworks. The architecture does not depend on the existence
of some library of feature-laden software. This allows you to use such
frameworks as tools, rather than forcing you to cram your system into their
limited constraints.</li>
<li>Testable. The business rules can be tested without the UI, database, web
server, or any other external element.</li>
<li>Independent of the UI. The UI can change easily, without changing the rest of
the system. A web UI could be replaced with a console UI, for example, without
changing the business rules.</li>
<li>Independent of the database. You can swap out Oracle or SQL Server for Mongo,
BigTable, CouchDB, or something else. Your business rules are not bound to the
database.</li>
<li>Independent of any external agency. In fact, your business rules don't know
anything at all about the interfaces to the outside world.</li>
</ul>
<p><img src="../img/CleanArchitecture.jpg" alt="Clean Arch" /></p>
<h2 id="the-dependency-rule"><a class="header" href="#the-dependency-rule">The dependency rule</a></h2>
<p><em>Source code dependencies must point only inward, toward higher-level policies.</em></p>
<p>Nothing in an inner circle can know anything at all about something in an outer
circle. In particular, the name of something declared in an outer circle must
not be mentioned by the code in an inner circle. That includes functions,
classes, variables, or any other named software entity. </p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Entities encapsulate enterprise-wide Critical Business Rules. An entity can be
an object with methods, or it can be a set of data structures and functions. It
doesn't matter so long as the entities can be used by many different
applications in the enterprise.</p>
<p>If you don't have an enterprise and are writing just a single application, then
these entities are the business objects of the application. They encapsulate the
most general and high-level rules. </p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>The software in the use cases layer contains application-specific business
rules. It encapsulates and implements all of the use cases of the system. These
use cases orchestrate the flow of data to and from the entities, and direct
those entities to use their Critical Business Rules to achieve the goals of the
use case.</p>
<p>Changes to the operation of the application will affect the use cases and,
therefore, the software in this layer. If the details of a use case change, then
some code in this layer will certainly be affected.</p>
<p>Similarly, data is converted, in this layer, from the form most convenient for
entities and use cases, to the form most convenient for whatever persistence
framework is being used (i.e., the database).</p>
<h2 id="framework-and-drivers"><a class="header" href="#framework-and-drivers">Framework and drivers</a></h2>
<p>Frameworks and tools such as the database and the web framework. Generally you
don't write much code in this layer, other than glue code that communicates to
the next circle inward.</p>
<h2 id="crossing-boundaries"><a class="header" href="#crossing-boundaries">Crossing Boundaries</a></h2>
<p>The same technique is used to cross all the boundaries in the architectures. We
take advantage of dynamic polymorphism to create source code dependencies that
oppose the flow of control so that we can conform to the Dependency Rule, no
matter which</p>
<h2 id="which-data-crosses-the-boundaries"><a class="header" href="#which-data-crosses-the-boundaries">Which data crosses the boundaries</a></h2>
<p>You can use basic structs or simple data transfer objects if you like. Or the
data can simply be arguments in function calls. Or you can pack it into a
hashmap, or construct it into an object. The important thing is that isolated,
simple data structures are passed across the boundaries. We don't want to cheat
and pass Entity objects or database rows. We don't want the data structures to
have any kind of dependency that violates the Dependency Rule.  Thus, when we
pass data across a boundary, it is always in the form that is most convenient
for the inner circle.</p>
<h2 id="the-humble-object-pattern"><a class="header" href="#the-humble-object-pattern">The humble object pattern</a></h2>
<p>The Humble Object pattern1 is a design pattern that was originally identified as
a way to help unit testers to separate behaviors that are hard to test from
behaviors that are easy to test. The idea is very simple: Split the behaviors
into two modules or classes. One of those modules is humble; it contains all the
hard-to-test behaviors stripped down to their barest essence. The other module
contains all the testable behaviours that were stripped out of the humble
object. </p>
<h2 id="database-gateways"><a class="header" href="#database-gateways">Database Gateways</a></h2>
<p>Between the use case interactors and the database are the database gateways.2
These gateways are polymorphic interfaces that contain methods for every create,
read, update, or delete operation that can be performed by the application on
the database. For example, if the application needs to know the last names of
all the users who logged in yesterday, then the UserGateway interface will have
a method named getLastNamesOfUsersWhoLoggedInAfter that takes a Date as its
argument and returns a list of last names.</p>
<p>Recall that we do not allow SQL in the use cases layer; instead, we use gateway
interfaces that have appropriate methods. Those gateways are implemented by
classes in the database layer. That implementation is the humble object. It
simply uses SQL, or whatever the interface to the database is, to access the
data required by each of the methods. The interactors, in contrast, are not
humble because they encapsulate application-specific business rules. Although
they are not humble, those interactors are testable, because the gateways can be
replaced with appropriate stubs</p>
<h2 id="data-mappers"><a class="header" href="#data-mappers">Data Mappers</a></h2>
<p>There is no such thing as an object relational mapper (ORM). The reason is
simple: Objects are not data structures. At least, they are not data structures
from their users' point of view. The users of an object cannot see the data,
since it is all private. Those users see only the public methods of that object.
So, from the user's point of view, an object is simply a set of operations.</p>
<p>A data structure, in contrast, is a set of public data variables that have no
implied behavior. ORMs would be better named “data mappers,&quot; because they load
data into  Where should such ORM systems reside? In the database layer of
course.</p>
<h2 id="service-listeners"><a class="header" href="#service-listeners">Service Listeners</a></h2>
<p>What about services? If your application must communicate with other services,
or if your application provides a set of services, will we find the Humble
Object pattern creating a service boundary? </p>
<p>Of course! The application will load data into simple data structures and then
pass those structures across the boundary to modules that properly format the
data and send it to external services.</p>
<p>At each architectural boundary, we are likely to find the Humble Object pattern
lurking somewhere nearby.</p>
<h1 id="partial-boundaries"><a class="header" href="#partial-boundaries">Partial Boundaries</a></h1>
<h2 id="skip-the-last-step"><a class="header" href="#skip-the-last-step">Skip the last step</a></h2>
<p>One way to construct a partial boundary is to do all the work necessary to
create independently compilable and deployable components, and then simply keep
them together in the same component. The reciprocal interfaces are there, the
input/output data structures are there, and everything is all set up—but we
compile and deploy all</p>
<h2 id="one-dimensional-boundaries"><a class="header" href="#one-dimensional-boundaries">One-dimensional boundaries</a></h2>
<p>The full-fledged architectural boundary uses reciprocal boundary interfaces to
maintain isolation in both directions. Maintaining separation in both directions
is expensive both in initial setup and in ongoing maintenance. </p>
<h2 id="facades"><a class="header" href="#facades">Facades</a></h2>
<p>An even simpler boundary is the Facade pattern. In this case, even the
dependency inversion is sacrificed. The boundary is simply defined by</p>
<p>Clean Architecture: That means that there is a potential architectural boundary
defined by this axis of change</p>
<p>So what do we do, we architects? The answer is dissatisfying. On the one hand,
some very smart people have told us, over the years, that we should not
anticipate the need for abstraction. This is the philosophy of YAGNI: “You
aren't going to need it.&quot; There is wisdom in this message, since
over-engineering is often much worse than under-engineering. On the other hand,
when you discover that you truly do need an architectural boundary where none
exists, the costs and risks can be very high to add such a boundary.</p>
<p>But this is not a one-time decision. You don't simply decide at the start of a
project which boundaries to implement and which to ignore. Rather, you watch.
You pay attention as the system evolves. You note where boundaries may be
required, and then carefully watch for the first inkling of friction because
those boundaries don't exist.</p>
<h1 id="the-main-component"><a class="header" href="#the-main-component">The main component</a></h1>
<p>In every system, there is at least one component that creates, coordinates, and
oversees the others. I call this component Main.</p>
<p>Its job is to create all the Factories, Strategies, and other global facilities,
and then hand control over to the high-level abstract portions of the system.
It is in this Main component that dependencies should be injected by a
Dependency</p>
<p>Injection framework. Once they are injected into Main, Main should distribute
those dependencies normally, without using the framework.</p>
<p>Think of Main as the dirtiest of all the dirty components.</p>
<p>Think of Main as a plugin to the application—a plugin that sets up the initial
conditions and configurations, gathers all the outside resources, and then hands
control over to the high-level policy of the application. Since it is a plugin,
it is possible to have many Main components, one for each configuration of your
application. </p>
<p>For example, you could have a Main plugin for Dev, another for Test, and yet
another for Production. You could also have a Main plugin for each country you
deploy to, or each jurisdiction, or each customer. </p>
<p>When you think about Main as a plugin component, sitting behind an architectural
boundary, the problem of configuration becomes a lot easier to solve.</p>
<h1 id="services-great-and-small-service-oriented-architectures-and-micro-service"><a class="header" href="#services-great-and-small-service-oriented-architectures-and-micro-service">Services: Great and small Service-oriented “architectures&quot; and micro-service</a></h1>
<p>“architectures&quot; have become very popular of late. The reasons for their current
popularity include the following:</p>
<ul>
<li>
<p>Services seem to be strongly decoupled from each other. As we shall see, this
is only partially true.</p>
</li>
<li>
<p>Services appear to support independence of development and deployment. Again,</p>
</li>
</ul>
<p>Services that simply separate application behaviors are little more than
expensive function calls, and are not necessarily architecturally significant.</p>
<p>This is not to say that all services should be architecturally significant.
There are often substantial benefits to creating services that separate
functionality across processes and platforms—whether they obey the Dependency
Rule or not. It's just that services, in and of themselves, do not define an
architecture. </p>
<h2 id="the-decoupling-fallacy"><a class="header" href="#the-decoupling-fallacy">The decoupling fallacy</a></h2>
<p>One of the big supposed benefits of breaking a system up into services is that
services are strongly decoupled from each other. After all, each service runs in
a</p>
<p>There is certainly some truth to this—but not very much truth. Yes, services are
decoupled at the level of individual variables. However, they can still be
coupled by shared resources within a processor, or on the network. What's more,
they are strongly coupled by the data they share.</p>
<p>For example, if a new field is added to a data record that is passed between
services, then every service that operates on the new field must be changed.</p>
<p>Service interfaces are no more formal, no more rigorous, and no better defined
than function interfaces. Clearly, then, this benefit is something of an
illusion. </p>
<p>First, history has shown that large enterprise systems can be built from
monoliths and component-based systems as well as service-based systems. Thus
services are not the only option for building scalable systems.</p>
<p>Yes! Services do not need to be little monoliths. Services can, instead, be
designed using the SOLID principles, and given a component structure so that new
components can be added to them without changing the existing components within
the service.</p>
<p>The services still exist as before, but each has its own internal component
design, allowing new features to be added as new derivative classes. Those
derivative classes live within their own </p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-cutting concerns</a></h2>
<p>What we have learned is that architectural boundaries do not fall between
services. Rather, those boundaries run through the services, dividing them into
components.</p>
<p>Those services do not define the architectural boundaries of the system;
instead, the components within the services</p>
<p>As useful as services are to the scalability and develop-ability of a system,
they are not, in and of themselves, architecturally significant elements.</p>
<p>A service might be a single component, completely surrounded by an architectural
boundary. Alternatively, a service might be composed of several components
separated by architectural boundaries. In rare2 cases, clients and services may
be so coupled as to have no architectural sig </p>
<h2 id="the-test-boundary"><a class="header" href="#the-test-boundary">The test boundary</a></h2>
<p>From an architectural point of view, all tests are the same.</p>
<p>Tests are the most isolated system component. They are not necessary for system
operation. No user depends on them. Their role is to support development, not
operation. And yet, they are no less a system component than any other. In fact,
in many ways they represent the model that all other system components should
follow.</p>
<h2 id="design-for-testability"><a class="header" href="#design-for-testability">Design for testability</a></h2>
<p>The extreme isolation of the tests, combined with the fact that they are not
usually deployed, often causes developers to think that tests fall outside of
the design of the system. This is a catastrophic point of view. Tests that are
not well integrated into the design of the system tend to be fragile, and they
make the system rigid and difficult to change. </p>
<h1 id="clean-embedded-architecture"><a class="header" href="#clean-embedded-architecture">Clean embedded architecture</a></h1>
<p>Software is this thing that can have a long useful life, but firmware will
become obsolete as hardware evolves.  Non-embedded engineers also write
firmware! You non-embedded developers essentially write firmware whenever you
bury SQL in your code or when you spread platform dependencies throughout your
code.</p>
<h2 id="app-titude-test"><a class="header" href="#app-titude-test">App-titude test</a></h2>
<p>Why does so much potential embedded software become firmware? </p>
<ol>
<li>“First make it work.&quot; You are out of business if it doesn't work.</li>
<li>“Then make it right.&quot; Refactor the code so that you and others can understand
it and evolve it as needs change or are better understood.</li>
<li>“Then make it fast.&quot; Refactor the code for “needed&quot; performance.</li>
</ol>
<h2 id="programming-to-interfaces-and-substitutability"><a class="header" href="#programming-to-interfaces-and-substitutability">Programming to interfaces and substitutability</a></h2>
<p>The idea of a layered architecture is built on the idea of programming to
interfaces. When one module interacts with another though an interface, you can
substitute one service provider for another. Many readers will have written
their own small version of printf for deployment in the target. As long as the
interface to your printf is the same as the standard version of printf, you can
override the service one for the other.</p>
<h1 id="the-database-is-a-detail"><a class="header" href="#the-database-is-a-detail">The database is a detail</a></h1>
<p>From an architectural point of view, the database is a non-entity—it is a detail
that does not rise to the level of an architectural element.</p>
<p>The structure you give to the data within your application is highly significant
to the architecture of your system. But the database is not the data model. The
database is piece of software. The database is a utility that provides access to
the data.</p>
<h2 id="relational-databases"><a class="header" href="#relational-databases">Relational databases</a></h2>
<p>The relational model is elegant, disciplined, and robust.</p>
<p>While relational tables may be convenient for certain forms of data access,
there is nothing architecturally significant about arranging data into rows
within tables. The</p>
<p>To mitigate the time delay imposed by disks, you need indexes, caches, and
optimized query schemes.</p>
<p>Over the years these systems have split into two distinct kinds: file systems
and relational database management systems (RDBMS). </p>
<p>File systems are document based. They provide a natural and convenient way to
store whole documents. They work well when you need to save and retrieve a set
of documents by name, but they don't offer a lot of help when you're searching
the content of those documents. It's easy to find a file named login.c, but it's
hard, and slow, to find every .c file that has a variable named x in it.</p>
<p>Database systems are content based. They provide a natural and convenient way to
find records based on their content. They are very good at associating multiple
records based on some bit of content that they all share.  Unfortunately, they
are rather poor at storing and retrieving opaque documents. </p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Isn't performance an architectural concern? Of course it is—but when it comes to
data storage, it's a concern that can be entirely encapsulated and separated
from the business rules. </p>
<h1 id="the-web-is-a-detail"><a class="header" href="#the-web-is-a-detail">The web is a detail</a></h1>
<p>The web is just the latest in a series of oscillations that our industry has
gone through since the 1960s. </p>
<p>The upshot is simply this: The GUI is a detail. The web is a GUI. So the web is
a detail. And, as an architect, you want to put details like that behind
boundaries that keep them separate from your core business logic. </p>
<h1 id="frameworks-are-a-details"><a class="header" href="#frameworks-are-a-details">Frameworks are a details</a></h1>
<p>Frameworks are not architectures—though some try to be.</p>
<h2 id="asymmetric-marriage"><a class="header" href="#asymmetric-marriage">Asymmetric Marriage</a></h2>
<p>The relationship between you and the framework author is extraordinarily
asymmetric. You must make a huge commitment to the framework, but the framework
author makes no commitment to you whatsoever. </p>
<h1 id="the-missing-chapter"><a class="header" href="#the-missing-chapter">The missing chapter</a></h1>
<p>All of the advice you've read so far will certainly help you design better
software, composed of classes and components with well-defined boundaries, clear
responsibilities, and controlled dependencies. But it turns out that the devil
is in the implementation details, and it's really easy to fall at the last
hurdle if you don't give </p>
<h2 id="package-by-layer"><a class="header" href="#package-by-layer">Package by layer</a></h2>
<p>The first, and perhaps simplest, design approach is the traditional horizontal
layered architecture, where we separate our code based on what it does from a
technical</p>
<p>The first, and perhaps simplest, design approach is the traditional horizontal
layered architecture, where we separate our code based on what it does from a
technical perspective. This is often called “package by layer.&quot; </p>
<p>In this typical layered architecture, we have one layer for the web code, one
layer for our “business logic,&quot; and one layer for persistence. In other words,
code is sliced horizontally into layers, which are used as a way to group
similar types of things. In a “strict layered architecture,&quot; layers should
depend only on the next adjacent lower layer.</p>
<h2 id="package-by-feature"><a class="header" href="#package-by-feature">Package by feature</a></h2>
<p>This is a vertical slicing, based on related features, domain concepts, or
aggregate roots (to use domain-driven design terminology). </p>
<h2 id="ports-and-adapters"><a class="header" href="#ports-and-adapters">Ports and adapters</a></h2>
<p>As Uncle Bob has said, approaches such as “ports and adapters,&quot; the “hexagonal
architecture,&quot; “boundaries, controllers, entities,&quot; and so on aim to create
architectures where business/domain-focused code is independent and separate
from the technical implementation details such as frameworks and databases. </p>
<p>The keen-eyed reader will notice that the OrdersRepository from previous
diagrams has been renamed to simply be Orders. This comes from the world of
domain-driven design, where the advice is that the naming of everything on the
“inside&quot; should be stated in terms of the “ubiquitous domain language.&quot; To put
that another way, we talk about “orders&quot; when we're having a discussion about
the domain, not the “orders repository.&quot;</p>
<p>It's also worth pointing out that this is a simplified version of what the UML
class diagram might look like, because it's missing things like interactors and
objects to</p>
<h1 id="conclusion-the-missing-advice"><a class="header" href="#conclusion-the-missing-advice">Conclusion: the missing advice</a></h1>
<p>The whole point of this chapter is to highlight that your best design intentions
can be  destroyed in a flash if you don't consider the intricacies of the
implementation strategy. Think about how to map your desired design on to code
structures, how to organize that code, and which decoupling modes to apply
during runtime and compile-time. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../tech/notes/software-arch/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../../tech/notes/software-arch/ddd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../tech/notes/software-arch/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../../tech/notes/software-arch/ddd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
