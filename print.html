<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lucas Contre</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="tech/notes/index.html"><strong aria-hidden="true">1.</strong> Notes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/enterprise-arch.html"><strong aria-hidden="true">1.1.</strong> Eneterprise Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/enterprise-arch/lawsnprinciples.html"><strong aria-hidden="true">1.1.1.</strong> Laws and Principle</a></li></ol></li><li class="chapter-item "><a href="tech/notes/software-arch/index.html"><strong aria-hidden="true">1.2.</strong> Software Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/software-arch/clean-arch.html"><strong aria-hidden="true">1.2.1.</strong> Clean Architecture</a></li><li class="chapter-item "><a href="tech/notes/software-arch/ddd.html"><strong aria-hidden="true">1.2.2.</strong> Domain Driven Design</a></li><li class="chapter-item "><a href="tech/notes/software-arch/lawsnprinciples.html"><strong aria-hidden="true">1.2.3.</strong> Laws and Principle</a></li></ol></li><li class="chapter-item "><a href="tech/notes/linux/index.html"><strong aria-hidden="true">1.3.</strong> Linux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/linux/which-distro.html"><strong aria-hidden="true">1.3.1.</strong> Which Linux Distro ?</a></li><li class="chapter-item "><a href="tech/notes/linux/capabilities.html"><strong aria-hidden="true">1.3.2.</strong> Capabilities</a></li><li class="chapter-item "><a href="tech/notes/linux/checking-system-performance.html"><strong aria-hidden="true">1.3.3.</strong> Performance check</a></li><li class="chapter-item "><a href="tech/notes/ssh/tunneling.html"><strong aria-hidden="true">1.3.4.</strong> ssh</a></li><li class="chapter-item "><a href="tech/notes/linux/systemd/systemd.html"><strong aria-hidden="true">1.3.5.</strong> Systemd</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/linux/systemd/journalctl.html"><strong aria-hidden="true">1.3.5.1.</strong> Journal</a></li></ol></li><li class="chapter-item "><a href="tech/notes/linux/containers/index.html"><strong aria-hidden="true">1.3.6.</strong> Containers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/linux/containers/podman.html"><strong aria-hidden="true">1.3.6.1.</strong> Podman</a></li></ol></li></ol></li><li class="chapter-item "><a href="tech/notes/philosphy.html"><strong aria-hidden="true">1.4.</strong> Software Philosphy</a></li><li class="chapter-item "><a href="tech/notes/security.html"><strong aria-hidden="true">1.5.</strong> Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/notes/security/tls.html"><strong aria-hidden="true">1.5.1.</strong> TLS</a></li></ol></li><li class="chapter-item "><a href="tech/notes/abstractions.html"><strong aria-hidden="true">1.6.</strong> Designing Abstractions</a></li></ol></li><li class="chapter-item expanded "><a href="tech/copy-paste/index.html"><strong aria-hidden="true">2.</strong> Copy/Paste</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tech/copy-paste/cloud/oneliners.html"><strong aria-hidden="true">2.1.</strong> Cloud</a></li><li class="chapter-item "><a href="tech/copy-paste/terminal/shell.html"><strong aria-hidden="true">2.2.</strong> Shell</a></li><li class="chapter-item "><a href="tech/copy-paste/terminal/arch.html"><strong aria-hidden="true">2.3.</strong> Arch</a></li><li class="chapter-item "><a href="tech/copy-paste/containers/oneliners.html"><strong aria-hidden="true">2.4.</strong> Containers</a></li><li class="chapter-item "><a href="tech/copy-paste/cloud/k8s.html"><strong aria-hidden="true">2.5.</strong> K8S</a></li><li class="chapter-item "><a href="tech/copy-paste/networking/oneliners.html"><strong aria-hidden="true">2.6.</strong> Networking</a></li><li class="chapter-item "><a href="tech/copy-paste/databases/mysql.html"><strong aria-hidden="true">2.7.</strong> MySQL</a></li><li class="chapter-item "><a href="tech/copy-paste/git/git.html"><strong aria-hidden="true">2.8.</strong> Git</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lucas Contre</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>Here you will find notes/ideas/annotations on material I have read about technology.
Also concepts that I find interesting, link to other posts and literal copy/paste sentences or even paragraphs from
books/blogs I have read.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eneterprise-architecture"><a class="header" href="#eneterprise-architecture">Eneterprise Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture"><a class="header" href="#software-architecture">Software Architecture</a></h1>
<p>A random recompilation of Enterprise Architecture principles and ideas you might find funny to relate/apply at work.</p>
<h2 id="peter-lawrence-principle"><a class="header" href="#peter-lawrence-principle">Peter Lawrence Principle</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Peter_principle">read more..</a></p>
<pre><code>People in a hierarchy tend to rise to &quot;a level of respective incompetence&quot;: 
Employees are promoted based on their success in previous jobs until they reach a 
level at which they are no longer competent, as skills in one job do not 
necessarily translate to another.
</code></pre>
<p>The concept was explained in the 1969 book The Peter Principle (William Morrow and Company) by Peter and Raymond Hull. (Hull wrote the text, based on Peter's research.) Peter and Hull intended the book to be satire,[3] but it became popular as it was seen to make a serious point about the shortcomings of how people are promoted within hierarchical organizations. The Peter Principle has since been the subject of much commentary and research.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture-1"><a class="header" href="#software-architecture-1">Software Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clean-architecture"><a class="header" href="#clean-architecture">Clean Architecture</a></h1>
<p>This are literal highlights from the <a href="https://books.google.es/books/about/Clean_Architecture.html?id=uGE1DwAAQBAJ&amp;source=kp_book_description&amp;redir_esc=y">Clean Architecture book</a> written by Robert C. Martin (Uncle Bob)</p>
<p>You can read his blog <a href="https://blog.cleancoder.com/">here</a></p>
<h2 id="foreword"><a class="header" href="#foreword">Foreword</a></h2>
<p>Describing software through architecture can reveal as much as it hides. It can
both promise more than what it can delivers and deliver more than what it
promises.</p>
<p><em>Architecture represents the significant design decisions that shape a system,
where significant is measured by cost of change.</em> - <em>Grady Booch</em></p>
<p>Time, money and effort give us a sense of scale to short between the large and
the small, to distinguish the architectural stuff from the rest. A good
architecture should not only meet the need of its users, developers, and owners
at a given point in time, but it also meets them over time.</p>
<p><em>If you think good architecture is expensive, try bad architecture.</em> - <em>Brian
Foote and Joseph Yoder</em></p>
<p>The path we are most interested is  the cleanest one, where we recognize the
softness of software and preserve it as a first-class property of the system.
Recognize that we operate with incomplete knowledge, but also understand that as
humans is something we're good at. Play more to our strength than to our
weaknesses. </p>
<p><em>Architecture is a hypothesis, that needs to be proven by implementation and
measurement.</em> - <em>Tom Glib</em></p>
<p>To walk this path requires care and attention, thought and observation, practice
and principle.  This at first might sound slow, but it's all in the way that you
walk.</p>
<p><em>Slow and steady wins the race.</em></p>
<h2 id="preface"><a class="header" href="#preface">Preface</a></h2>
<p>Uncle Bob claims to have taken part and tons of different systems from games to
multi-threaded, multi processor, GUI and databases apes and all of them follows
the same rules.</p>
<p>He concludes &quot;<em>the rules of software architecture are independent of every other
variable.</em>&quot; He based on the fact that even though technology has improved
drastically in term of new hardware more libraries and new languages, the bases
are the same. It's made of the same stuff. It's made of <code>if</code> statements,
assignments statements, and <code>while</code> loops. This changeless NESS of the code is
the reason that the rules o software architecture are so consistent across
system types. Nevertheless, one thing has changed: Back then, they didn't know
what the rules were.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Getting something to work --once-- just isn't that hard. Getting it right is
another matter entirely. Getting software right is hard and most young
programmers don't have what it needs or simply doesn't care about writing clean
code.</p>
<p>When you get software right, something magical happens: You don't need hordes of
programmers to keep it working. You don't need massive requirements documents
and huge issue tracking systems. When software is done right it requires a
fraction the human resources to create and maintain.</p>
<p>Unfortunately, It is far more common to fight your way through terrible software
designs that it is to enjoy the pleasure of working with a good one.</p>
<h1 id="part-i-what-is-design-and-architecture-"><a class="header" href="#part-i-what-is-design-and-architecture-">Part I: What is design and architecture ?</a></h1>
<p>There has been a lot of confusion about design and architecture over the years
and one of the goals of this book is to cu through all that confusion and to
define what architecture and design are. For starters, there's no difference at
all.</p>
<p>The work <em>architecture</em> is often used in the context of something at a high
level that is divorced from the lower-level details, whereas <em>design</em> more often
seems to imply structures and decisions at a lower level. But this usage is
nonsensical when you look at what a real architect does. </p>
<h3 id="the-goal"><a class="header" href="#the-goal">The goal</a></h3>
<p>Both design and architecture can be used to describe a continuum of decisions
from the highest to the lowest levels. And what drives that decision ? </p>
<p><em>The goal of software architecture is to minimize the human resources required
to build and maintain the required system.</em></p>
<p>Once again like in the foreword remark the importance of taking the time to
think thing through by stating several quotes and showing a case study on the
matter.</p>
<p><em>The race is not to the swift, nor the battle to the strong.</em></p>
<p><em>The more haste, the less speed.</em></p>
<p><em>Making messes is always slower than staying clean.</em></p>
<p><em>The only way of going fast, is to go well</em></p>
<p>The developers may think that the answer is to sart over from scratch and
redesign the whole system --  but that's just the hare talking again.</p>
<p><em>Their overconfidence will drive the redesign into the same mess as the original
project.</em></p>
<h2 id="a-tale-of-two-values"><a class="header" href="#a-tale-of-two-values">A tale of two values</a></h2>
<p>Uncle bob says that software mainly provide two values: <strong>Behavior</strong> and
<strong>Architecture</strong>. </p>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<p><strong>Behavior</strong> , making a machine behave in a way that meets the stakeholders
requirements. Functionality. Some programmers think this is their entire job.
They think that their job is to implement requirements and fix bugs. They are
sadly wrong.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p><strong>Architecture</strong>, has to do with the word software. <em>ware</em> being product and the
word <em>soft</em> that is where the second value lies.</p>
<p>Software was invented to be <em>soft</em>. It was intended to be a way to easily change
the behavior of machines. If we'd wanted the behavior of machines to be hard to
change, we would have called it <em>hardware</em>.</p>
<p>Architecture should be agnostics of shape.</p>
<h3 id="eisenhower-matrix"><a class="header" href="#eisenhower-matrix">Eisenhower Matrix:</a></h3>
<p><em>The urgent is not important and the important are never urgent.</em> </p>
<p>Those things that are urgent are rarely of great importance, and those things
that are important are seldom of great urgency.</p>
<p>The first value of software --behavior-- is urgent but not always important.</p>
<p>The second value of software --architecture-- is important but never
particularly urgent.</p>
<ol>
<li>Urgent and Important</li>
<li>Not urgent and important</li>
<li>Urgent and not important</li>
<li>Not Urgent and not important</li>
</ol>
<p>Business managers and developers often place the 3 option to the first place.</p>
<h1 id="part-ii-starting-from-the-brick-programming-paradigms"><a class="header" href="#part-ii-starting-from-the-brick-programming-paradigms">Part II: Starting from the brick: Programming paradigms</a></h1>
<p>First programming revolution was that of languages. Languages relieved the
programmers of the drudgery of translating their programs into binary.</p>
<p>Another revolution, probably more significant, revolution was in programming
paradigms. Paradigms area ways of programming, relatively unrelated to
languages. <em><strong>A paradigm tells you which programming structures to use, and when
to use them</strong></em>. To date, there have been three such paradigms and there are
unlikely to be any others. </p>
<h2 id="paradigm-overview"><a class="header" href="#paradigm-overview">Paradigm overview</a></h2>
<p>The three paradigms included in this overview are <strong>Structured</strong>, <strong>Object
oriented</strong> and <strong>Functional.</strong></p>
<h3 id="structured"><a class="header" href="#structured">Structured</a></h3>
<p>The first one to be adopted (but no the first to be invented) was structured
programming, discovered by Dijkstra. He showed that the use of unrestrained
jumps (<code>goto</code> statements) is harmful to program structure so he replaced those
jumps with the more familiars <code>if/then/else</code> and <code>do/while/until</code> constructs.</p>
<p><em>Structured programming imposes discipline on direct transfer of control</em></p>
<h3 id="object-oriented"><a class="header" href="#object-oriented">Object Oriented</a></h3>
<p>Two years earlier Object oriented programming was discovered by Ole and Kristen.
These two programmer noticed that the function call stack frame in the <code>ALGOL</code>
language could be moved to a heap, thereby allowing local variables declared by
a function to exist long after the function returned. The function become a
constructors for a class, the local variables became instance variables, and the
nested functions became methods. This lead inevitably to the discovery of
polymorphism through the disciplined use of function pointers.</p>
<p><em>Object-oriented programming imposes discipline on indirect transfer of control</em></p>
<h3 id="functional"><a class="header" href="#functional">Functional</a></h3>
<p>The first to be invented was functional programming. Its  invention predates
computer programming itself. Derived from 1-Calculus, its main foundational
notions is immutability -- that is, the notion that the values of symbols do not
change. </p>
<p><em>Functional programming imposes discipline upon assignment</em></p>
<h3 id="food-for-thought"><a class="header" href="#food-for-thought">Food for thought</a></h3>
<p>Notice the pattern that I've quite deliberately set up in introducing these
three programming paradigms: Each of them removes capabilities from the
programmer. None of them adds new capabilities. Each imposes some kind of extra
discipline that is negative in its intent. The paradigms tell us what not to do,
more than they tell us what to do.</p>
<p>Every paradigm takes aways something. The three paradigms together remove <code>goto</code>
statements, functions pointers, and assignment. Is there anything left to take
away ? These were discovered in the span of 10 years, in the many decades that
have followed, no new paradigms have been added.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>What does this has to do with architecture ? We use polymorphism as the
mechanism to cross architectural boundaries; we use functional programming to
impose discipline on the locations of and access to data; and we use structured
programming as the algorithmic foundation of our models. Notice how well those
thee align with the three big concerns of architecture function, separation of
components, and data management.</p>
<h2 id="structured-programming"><a class="header" href="#structured-programming">Structured Programming</a></h2>
<p>Dijkstra realized that programming is hard and that programmer don't do it very
well. A program of any complexity contains too many details for a human brain to
manage without help.  To solve this issue, Dijkstra tried to apply the
mathematical discipline of proof. His vision was the construction of Euclidean
hierarchy of postulates, theorems, corollaries, and lemmas. Programmer would use
proven structures, and tie them together with code that they would prove correct
themselves. He discovered that certain uses of <code>goto</code> statements prevent modules
from being decomposed recursively into smaller units therefore preventing the
use of the divide-and-conquer approach necessary for reasonable proofs. However,
other uses of goto didn't have this problem. He realized that this <em>good</em> uses
of <code>goto</code> corresponds to simple selection and iteration control structures. All
programs can be constructed with three structures: Sequence, Selection and
Iteration. This very same structures made a program provable.</p>
<p>The Euclidean hierarchy of theorems was never built. And programmers never saw
the benefits of working through the laborious process of formally proving each
and every little function correct. Of course, formal, Euclidean style,
mathematical proofs is not the only strategy for proving something correct.
Another highly successful strategy is the scientific method. Proving thins
incorrect. That's the nature of scientific theories and laws: They are
falsifiable but not provable. Science work by proving statement false, not true.
We take as true the statements that, after a long time, we couldn't prove true. </p>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<p>Dijkstra once said: <em>&quot;Testing shows the presence, not the absence, of bugs&quot;.</em>
Functions can be proven to be incorrect with a test, but it can't be proven
correct.  Software development is not like mathematical endeavor, even though is
it seems to manipulate mathematical constructs. Rather, software is like
science. We show correctness by failing in proving incorrectness.</p>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p>In conclusion, structured programming is this ability to create falsifiable
units of programming that makes structured programming valuable today.  At the
architecture level, this is why we still consider functional decomposition to be
on of our best practices. </p>
<h2 id="object-oriented-programming"><a class="header" href="#object-oriented-programming">Object Oriented Programming</a></h2>
<p>The basis of a good architecture is the correct understanding and application of
the principles of Object-oriented design (OO) OO Design is the combination of
data and function but is also explain as &quot;A way to model the real world&quot;.  The
three magic word to explain OO are encapsulation, inheritance and polymorphism.</p>
<h3 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h3>
<p>The encapsulation of data and functions lets us draw a line and bound these
together but the idea is certainly not unique to OO. Indeed, we had perfect
encapsulation in C. Perfect encapsulation in a non-OO language.  C#, Java and
some OO language it's imposible to separate the declaration and definition of a
class. Therefore they abolished the header/implementation like pure <code>C</code> ,where
you would have a <code>library.h</code>, weakening encapsulation.  For these reasons it is
difficult to accept that OO depends on strong encapsulation. In fact, many OO
languages have little or no enforced encapsulation at also.</p>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Inheritance is simply the redeclaration of a group of variables and functions
within an enclosing scope. We could do this with C long time ago or at least we
had a trick, but it's not inheritance per se. Moreover, multiple inheritance is
considerably more difficult to achieve with such trickery.  It's fair to say
that while OO did not give us something completely brand new, it did make the
masquerading of data structures significantly more convenient.</p>
<h3 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h3>
<p>We did have polymorphism in languages before OO. For example in the <code>getchard()</code>
and <code>putchar()</code> which read and write from the STDIN and STDOUT.  The UNIX
operating system requires that every IO devices drivers provide five standard
functions: <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code> and <code>seek</code> and <code>seek</code>. The
signatures of these functions must be identical for every IO driver The bottom
line is that polymorphism is an application of pointers to functions.
Programmers have been using these to achieve polymorphic behavior since 1940s.
In other word, OO has provide nothing new.</p>
<p>The problem with pointers to functions is that they are dangerous. Such use is
driven by a set of manual conventions. If any programmer fails to remember these
conventions, the resulting bug can be hard to track down and eliminate.  OO
languages eliminate these conventions and, therefore, these dangers. Using OO
languages, polymorphism is trivial. That fat provides enormous power that old C
programmer could only dream of. On this basis, we can conclude that OO imposes
discipline on indirect transfer of control. </p>
<h3 id="the-power-of-polymorphism"><a class="header" href="#the-power-of-polymorphism">The power of polymorphism</a></h3>
<p>The power of polymorphism lays on the fact that by implementing functions in,
for example, UNIX IO drivers, then we can assure that the program that use those
functions does not depend on the source code of those &quot;not-dependencies&quot; (IO
Drivers.) In short IO drivers have become plugins to out program. The
plug-in architecture has been interested to achieve IO devices independence,
and has been implemented in almost every operating system since its
introduction.  OO allows the plug-in architecture to be used anywhere, for
anything.</p>
<h3 id="dependency-inversion"><a class="header" href="#dependency-inversion">Dependency Inversion</a></h3>
<p>Before a safe and convenient mechanism for polymorphism was available, <code>Flow control</code> and <code>Source Code Dependency</code> followed the same path. In the typical
calling tree, main functions called high-level functions, mid-level functions,
which called low-level functions.  In this scenario the flow of control was
dictated by the behavior of the dependencies and the dependencies were dictated
by that flow control.  When polymorphism brought into play, something very
different can happen.</p>
<p><img src="tech/notes/software-arch/../img/dependency_inversion.png" alt="di" /></p>
<p>In <code>Figure 1</code> we can see the classical approach where Flow of control goes on
the same direction as the dependency. <code>Figure 2</code>, shows us how <em>Object A</em> a
high-level function calls a functions in <em>Object B</em> a middle-level function.
The fact that it calls this function through the interface is a source code
contrivance. At runtime, the interface doesn't exist. <em>Object A</em> simply calls
the function within <em>Object B</em> Notice that here the flow of control still goes
from <em>Object A</em> the high-level function to the low-level function <em>Object B</em>.
The fact that OO languages provide safe and convenient polymorphism means that
any source code dependency, no matter where it is, can be inverted by inserting
an interface between them. That's the power that OO provides. That's what OO is
really all about- at least from an architect point of view.  As an example, you
can rearrange the source doe dependencies of your system so that the database
and the user interface (UI) depend on the business rules rather than the other
way around.  This means that the Database and de UI can be plugins to the
business rules. This means that the business rules never mentions the UI or the
Database.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>OO is the ability, through the use of polymorphism, to gain absolute control
over every source code dependency in the system. It allows the architect to
create a plug-in architecture, in which modules that contain high-level policies
are independent of module that contain los-level details. The low-level details
are relegated to plug-in modules that can be deployed and developed
independently from the modules that contain high-level policies.</p>
<h1 id="part-iii-design-principles"><a class="header" href="#part-iii-design-principles">Part III: Design Principles</a></h1>
<p>The SOLID principles tell us how to arrange our functions and data structures
into classes, and how those classes should be interconnected. A class is simply
a coupled grouping of functions and data. Every software system has such
groupings, Wether they are called classes or not. The SOLID principles apply to
those groupings.</p>
<h2 id="solid"><a class="header" href="#solid">S.O.L.I.D</a></h2>
<p>The goal of the principles is the creation of mid-level software structures
that:</p>
<ul>
<li>Tolerate change</li>
<li>Are easy to understand</li>
<li>Are the basis of components than can be used in many software systems</li>
</ul>
<h2 id="single-responsibility-principle-srp"><a class="header" href="#single-responsibility-principle-srp">Single responsibility principle (SRP)</a></h2>
<p>Of all of the SOLID principles, the SRP might be the least understood and it
might be due to its name. It is too easy for programmers to hear the name and
then assume that it means that every module should do just one thing.  Make no
mistake, there is a principle like that. A <strong>function</strong> should do one, and only
one, thing. We use that principle when we are refactoring large functions into
smaller functions; we use it at the lowest levels. But it is now one of the
SOLID principles-- it is not SRP.</p>
<p>A module should be responsible for one and only one actor (An actor being a
group of users or stakeholders that will be likely to request changes to the
system).</p>
<p>Now, what do we mean by the word &quot;module&quot; ? The simplest definition is just a
source file. Most of the time that definition works fine. Some languages and
development environments, though, don't use source files to contain their code.
In those cases a module is just a cohesive set of functions and data structures.</p>
<p>[SEE THE EXAMPLE OF THE EMPLOYEE ON THE BOOK]</p>
<p>To conclude, the single responsibility principle is about functions and classes
but it appears in a different form at two more levels. At the level of
components, it becomes the Common Clausure Principle. At the architectural
level, it becomes the Axis of change responsible for the creation of
Architectural Boundaries.</p>
<h2 id="the-open-closed-principle-ocp"><a class="header" href="#the-open-closed-principle-ocp">The open-closed principle (OCP)</a></h2>
<p>A software should be open for extension but closed for modification In other
words, the behaviour of a software artifact ought to be extendible, without
having to modify that artifact. And this is the most fundamental reason that we
study software architecture. A good software architecture would reduce the
amount of changed code to the barest minimum. Ideally, zero.  How?  By properly
separating the things that change for different reasons (SRP) and then
organizing the dependencies between them (DIP).</p>
<p>Bellow we see an image that's fully explained on the book. I suggest reviewing
this example in particularly.</p>
<p><img src="tech/notes/software-arch/../img/financial_ocp.png" alt="financial ocp" /></p>
<p>If component A should be protected from changes in component B, then B depends
on A. We wan the <em>Controller</em> to be protected from changes in the <em>Presenters</em>.
We want to protect the <em>Presenters</em> from changes in the views. WE wan to protect
the <em>Interactor</em> from changes in-- well, everything.  Why should the
<em>Interactor</em> hold such a privilege position ? Because it contains the business
rules, it contains the higher level policies of the application.  This is how
OCP works at the architectural level. Architects separate functionality based on
how, why, and when it changes, and then organize that separated functionality
into a hierarchy of components. Higher-level components or protected from
changes made to the lower-level components.</p>
<p>OCP is the one driving forces behind the architecture of systems. The goal to
make te system easy to extend without incurring a high impact of change. This
goal is accomplished by partitioning the system into components, and arranging
from changes in lower-level components. </p>
<h2 id="the-liskov-substitution-principle-lsp"><a class="header" href="#the-liskov-substitution-principle-lsp">The Liskov substitution principle (LSP)</a></h2>
<p>Substitutability is a principle in object-oriented programming stating that, in
a computer program, if S is a subtype of T, then objects of type T may be
replaced with objects of type S without altering any of the desirable properties
of the program.</p>
<h3 id="lsp-and-architecture"><a class="header" href="#lsp-and-architecture">LSP and architecture</a></h3>
<p>In the earlier ages of OO we thought LSP as a way to guide the use of
inheritance, as shown in the previous sections. However, over the years the LSP
has morphed into a broader principle of software design that pertains to
interface and implementations. We could have several Ruby clases that implement
the same interface or we might have a set of services that all respond to the
same REST interface.  In all of these situations, and more, the LSP is
applicable because there are users who depend on well-defined interfaces. In
conclusion, the LSP can, and should, be extended to the level of architecture.
A simple violation of substitutability, can cause a system's architecture to be
polluted with significant amount of extra mechanisms.</p>
<h2 id="the-interface-segregation-principle-isp"><a class="header" href="#the-interface-segregation-principle-isp">The interface segregation principle (ISP)</a></h2>
<p>The interface-segregation principle (ISP) states that no client should be forced
to depend on methods it does not use. In general is harmful to depend on modules
that contain more than you need. This is obviously true for source code
dependencies that can force unnecessary recompilation and redeployment-- but it
is also true at a much higher, architectural level.</p>
<h2 id="the--dependency-inversion-principle-dip"><a class="header" href="#the--dependency-inversion-principle-dip">The  dependency inversion principle (DIP)</a></h2>
<p>The dependency inversion principle (DIP) tells us that the most flexible systems
are those in which source code dependencies refer only to abstractions, not to
congregations.  It is the volatile concrete elements of our system that we want
to avoid depending on. Those are the modules  that we are actively developing,
and that are undergoing frequent change. Interfaces are less volatile that
implementations. This implications boils down to a set of very specific coding
practices: </p>
<ul>
<li>Don't refer to volatile concrete classes. Refer to abstract interfaces
instead.</li>
<li>Don't derive from volatile concrete classes.</li>
<li>Don't override concrete functions. Concrete functions often require source
code when you override those functions, you do not eliminate those
dependencies-- indeed you inherit them.</li>
<li>Never mentions the name of anything concrete and volatile.</li>
</ul>
<h3 id="factories-this-is-the-posta-dd"><a class="header" href="#factories-this-is-the-posta-dd">Factories this is the posta dd</a></h3>
<p>To comply to these rules, the creation of volatile concrete objects requires
special handling. The Factory pattern is a creational patter that defines an
Interface for creating an object and defers instantiation until runtime. It is
commonly used when you don't know how many or what type of objects will be
needed until during runtime.</p>
<h1 id="part-iv--components-principles"><a class="header" href="#part-iv--components-principles">Part IV:  Components principles</a></h1>
<p>If SOLID principles tell us how to arrange the bricks into walls and rooms, then
the component principles tell us how to arrange the rooms into buildings.</p>
<h2 id="components-the-smallest-entities-that-can-be-deployed-as-a-single-unit"><a class="header" href="#components-the-smallest-entities-that-can-be-deployed-as-a-single-unit">Components The smallest entities that can be deployed as a single unit.</a></h2>
<p>Examples - jar file, DLL, shared library, etc.</p>
<p>They can be combined into single binaries or kept separate as plugins to other
binaries.  Whatever the use-case, good components always retain the ability to
be independently deployable and, hence, independently developable.</p>
<h2 id="component-cohesion"><a class="header" href="#component-cohesion">Component cohesion</a></h2>
<p>There are three principles of component cohesion.</p>
<ul>
<li>REP:  The Reuse/Release equivalence principle</li>
<li>CCP:  The Common Closure Principle</li>
<li>CRP:  The Common Reuse Principle</li>
</ul>
<h3 id="the-reuserelease-equivalence-principle"><a class="header" href="#the-reuserelease-equivalence-principle">The reuse/release equivalence principle</a></h3>
<p><strong>The granule of reuse is the granule of release</strong> </p>
<p>We are now living in the age of software reuse -- a fulfillment of one of the
oldest promises of the object-oriented model.  From a software design and
architecture point of view, this principle means that the classes and modules
that are formed into a component must belong to a cohesive group classes and
modules that are grouped together into a component should be releasable together
though it is hard to precisely explain the glue that holds these together into a
single component. </p>
<p>The weakness of this principle is more than compensated by the strength of next
two principle strongly define this principle in the negative sense.</p>
<h3 id="the-common-closure-principle"><a class="header" href="#the-common-closure-principle">The common closure principle</a></h3>
<p><strong>Gather into component those classes that change for the same reasons and at
the same times. Separate into different components those classes that change at
different times and for different reasons</strong></p>
<p>The CCP basically says that a component should not have multiple reasons to
change. For most application, maintainability is more important than
reusability. If the code in an application must change, you would like all of
the changes to occur in one single component. </p>
<h4 id="similarity-with-srp-the-ccp-is-the-component-form-of-the-srp-the-srp-tells"><a class="header" href="#similarity-with-srp-the-ccp-is-the-component-form-of-the-srp-the-srp-tells">Similarity with SRP The CCP is the component form of the SRP. The SRP tells</a></h4>
<p>us to separate methods into different classes, if they change for different
reasons. The CCP tells us to separate classes into different components, if they
change for different reasons.</p>
<h3 id="the-common-reuse-principle"><a class="header" href="#the-common-reuse-principle">The common reuse principle.</a></h3>
<p><strong>Don't force users of a component to depend on things they don't need.</strong></p>
<p>The CRP is yet another principle that helps us to decide which classes and
modules should be placed into a component. </p>
<p>We want to make sure that classes that we put together into a component are
inseparable--  that it is impossible to depend on some and not on the others.
Otherwise, we will be redeploying more components than is necessary, and wasting
significant effort.</p>
<h4 id="relation-to-isp"><a class="header" href="#relation-to-isp">Relation to ISP.</a></h4>
<p>The CRP is the generic version of the ISP. The ISP advises us not to depend on
classes that have methods we don't use. The CRP advises us not to depend on
components that have classes we don't use. </p>
<h3 id="the-tension-diagram-for-component-cohesion"><a class="header" href="#the-tension-diagram-for-component-cohesion">The tension diagram for component cohesion</a></h3>
<p>The REP and CCP are inclusive principles: Both tend to make components larger.
The CRP is an exclusive principle, driving components to be smaller. It is the
tension between these principles that good architects seek to resolve. </p>
<p><img src="tech/notes/software-arch/../img/CohesionPrinciplesTensionDiagram.jpg" alt="Tensions Cohesion Diagram " /></p>
<p>An architect who focuses on just the REP and CRP will find that too many
component are impacted when simple changes are made.. In contrast, and architect
who focuses too strongly on the CCP and REP will cause too many unneeded
releases to be generated.</p>
<p>Generally projects tend to start on the right hand of the triangle, where the
only sacrifice is reuse. As the project matures, and other projects begin to
draw from it, the project will slide over to the left.  It has more to do with
the way that project is developed and used than with what the project actually
does.</p>
<p>Moreover, the balance is almost always dynamic. That is the partitioning that is
appropriate today might not be  appropriate next year.</p>
<h2 id="component-coupling"><a class="header" href="#component-coupling">Component Coupling</a></h2>
<h3 id="the-acyclic-dependencies-principle"><a class="header" href="#the-acyclic-dependencies-principle">The Acyclic dependencies principle</a></h3>
<p><em>Allow no cycles in the component dependency graph</em></p>
<p>Have you ever worked all day, then go home, only to arrive the next morning to
find that your stuff no longer works ? This is because someone stayed later than
you and changes something you depend on! I call this &quot;The morning after
syndrome&quot;</p>
<p>Over the last two decades only two solutions to this problem have evolved. The
first is the &quot;Weekly build&quot; and &quot;The Acyclic dependency principle&quot;</p>
<h4 id="the-weekly-build"><a class="header" href="#the-weekly-build">The weekly build</a></h4>
<p>Used to be common in medium-sized projects. It works like this: All the
developers ignore each other the first four days of the week. Then, on Friday,
they integrate all their changes and build the system.  Unfortunately, as the
project grows, it becomes less feasible to finish integrating the project on
Friday since the integration time increase with the project size.</p>
<h4 id="eliminating-dependency-cycles"><a class="header" href="#eliminating-dependency-cycles">Eliminating dependency cycles</a></h4>
<p>The solution to this is to partition the development environment into releasable
components. The components become units of work that can be the responsibility
of a single developer, or a team of developers. Releases are donde by components
now. Changes made to one component do not need to have an immediate affect on
other teams. Each team can decide for itself when to adapt its own components to
new releases of the components. Moreover, integration happens in small
increments.  For this strategy to work, there can be no cycles in the component
dependency graph. It's a DAG (Directed Acyclic Graph).  Whenever we find a
cyclic on the dependency graph (as seen in the figure between Entities and
Authorizer) we should make sure to remove it.  <img src="tech/notes/software-arch/../img/DependencyGraph.jpg" alt="Dependency Graph" /> To break the cycle we can take two
approaches.</p>
<ol>
<li>
<p>Apply the Dependency Inversion Principle (DIP). So we can make Authorizer
depend on Entities and not the other way around.  <img src="tech/notes/software-arch/../img/DependencyGraphDIP.jpeg" alt="DIP for Dependency Cycle" /></p>
</li>
<li>
<p>Create a new component that both Authorizer and Entities depend on.  <img src="tech/notes/software-arch/../img/DependencyGraphNewComponent.jpeg" alt="New Component for Dependency Cycle" /></p>
</li>
</ol>
<h3 id="top-down-design-the-component-dependency-graph-structure-cannot-be-designed"><a class="header" href="#top-down-design-the-component-dependency-graph-structure-cannot-be-designed">TOP-DOWN Design The component dependency graph structure cannot be designed</a></h3>
<p>from the top down. It is not one of the first things about the system that is
designed, but rather evolves as the system grows and changes.  In fact, the
component dependency diagrams have very little to do with describing the
function of the application. Instead, they are a map to the buildability and
maintainability of the application. If there's no software to build or maintain,
then, there's no need for such diagram.</p>
<h3 id="the-stable-dependencies-principle"><a class="header" href="#the-stable-dependencies-principle">The stable dependencies principle</a></h3>
<p><em>Depend in the direction of stability</em></p>
<p>Design cannot be completely static. Some volatility is necessary if the design
is to be maintain. By conforming to the <strong>Common closure principle (CCP)</strong>, we
create component that are sensitive to certain kinds of changes bu immune to
others.  By conforming to the <strong>Stable dependencies principle (SDP)</strong> we ensure
that module that are intended to be easy to change are not depended on by
modules that are harder to change.</p>
<h3 id="stability"><a class="header" href="#stability">Stability</a></h3>
<p>Stability is related to the amount of work required to make a change. One way to
make a software component difficult to change, is to make lots of other software
depend on it. The way we measure this stability is by counting the number of
dependencies that enter and leave that component.</p>
<p><strong>Fan-in:</strong> Incoming dependencies <strong>Fan-out:</strong> Outgoing dependencies
<strong>I(Instability):</strong> Fan-in / (Fan-in+ Fan-out)</p>
<p>Not all components should be stable, if all components in a system were
maximally stable, the system would be unchangeable. We wan to design system with
components that are stable and components that are unstable. </p>
<h3 id="the-stable-abstraction-principle-a-component-should-be-as-abstract-as-it-is-stable"><a class="header" href="#the-stable-abstraction-principle-a-component-should-be-as-abstract-as-it-is-stable">The stable abstraction principle <em>A component should be as abstract as it is stable</em></a></h3>
<p>Software that encapsulates hight level policies should go in stable components
while unstable components should contain volatile software. The answer is found
in the OCP. This principle tells us that it is possible and desirable to
create classes that are flexible enough to be extended without requiring
modification. Which kind of classes conform to this principle? Abstract
classes.</p>
<p>The Stable Abstractions Principle (SAP) sets up a relationship between stability
and abstractness. On the one hand, it says that a stable component should also
be abstract so that its stability does not prevent it from being extended. On
the other hand, it says that an unstable component should be concrete since it
its instability allows the concrete code within it to be easily changed. It
should consist of interfaces and abstract classes so that it can be extended.</p>
<p>The SAP and the SDP combined amount to the DIP for components. This is true
because the SDP says that dependencies should run in the direction of stability,
and the SAP says that stability implies abstraction. Thus dependencies run in
the direction of abstraction </p>
<h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>First if all, a software architect is a programmer; and continues to be a
programmer. Never fall into the lie that a software architect is not a
programmer.  The architecture of a software system is the shape given to that
system by those who build it. The form of that shape is in the division of that
system into components, the arrangement of those components, and the ways in
which those components communicate with each other.</p>
<p><em>The strategy behind that facilitation is to leave as many options open as
possible, for as long as possible</em></p>
<p>The primary goal of architecture is to preserve the life cycle of the system.
Te ultimate goal is to minimize the lifetime cost of the system and to maximize
programmer productivity.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>A group of 5 developers can quite effectively work together to develop a
monolithic system without well-defined components or interfaces, on the other
hand, a system developed by 5 different teams can not make progress unless the
system is divided into well define components.</p>
<p>Such a component-per-team architecture is not likely to be the best architecture
for deployment, operation, and maintenance of the system.  Nevertheless, it is
the architecture that a group of team will gravitate toward if they are
driven solely by development schedule.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>A goal of software architecture should be to make a system that can be easily
deployed with a single action.  Unfortunately, deployment strategy is seldom
considered during initial development. This leads to system very easy to deploy
but very difficult to develop.</p>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<p>The impact of architect on system operation tends to be les dramatic than the
impact of architecture on development, deployment, and maintenance. Almost any
operational difficulty can be resolved by throwing more hardware at the system
without drastically impacting software architecture.  Architecture should reveal
operation. The architecture of the system should elevate the use cases, the
visible landmark for the developers. This simplifies the understanding of the
system and, therefore, greatly aids in development and maintenance.</p>
<h2 id="maintenance-the-never-ending-parade-of-new-features-and-the-inevitable-trail"><a class="header" href="#maintenance-the-never-ending-parade-of-new-features-and-the-inevitable-trail">Maintenance The never-ending parade of new features and the inevitable trail</a></h2>
<p>of defects and corrections consume vast amounts of human resources.  The primary
cost of maintenance is in spelunking and risk. Spelunking is the cost of digging
through the existing software, trying to determine the best place and the best
strategy to add a new feature or to repair a defect. While making such changes,
the likelihood of creating inadvertent defects is always there, adding to the
cost of risk.</p>
<h2 id="keeping-option-open-as-we-described-in-an-earlier-chapter-software-has-two"><a class="header" href="#keeping-option-open-as-we-described-in-an-earlier-chapter-software-has-two">Keeping option open As we described in an earlier chapter, software has two</a></h2>
<p>types of value: the value of its behavior and the value of its structure. The
second of these is the greater of the two because it is this value that makes
software soft.</p>
<p>All software systems can be decomposed into two major elements: policy and
details. The policy element embodies all the business rules and procedures. The
policy is where the true value of the system lives.</p>
<p>The details are those things that are necessary to enable humans, other systems,
and programmers to communicate with the policy, but that do not impact the
behavior of the policy at all. They include IO devices, databases, web systems,
servers, frameworks, communication protocols, and so forth. </p>
<p>The goal of the architect is to create a shape for the system that recognizes
policy as the most essential element of the system while making the details
irrelevant to that policy.</p>
<p>• It is not necessary to choose a database system in the early days of
development, because the high-level policy should not care which kind of
database will be used. Indeed, if the architect is careful, the high-level
policy will not care if the database is relational, distributed, hierarchical,
or just plain flat files.</p>
<p>• It is not necessary to choose a web server early in development, because the
high-level policy should not know that it is being delivered over the web. If
the high-level policy is unaware of HTML, AJAX, JSP, JSF, or any of the rest of
the alphabet soup of web development, then you don't need to decide which web
system to use until much later in the project. Indeed, you don't even have to
decide if the system will be delivered over the web. </p>
<p>• It is not necessary to adopt REST early in development, because the high-
level policy should be agnostic about the interface to the outside world.  Nor
is it necessary to adopt a micro-services framework, or a SOA framework. Again,
the high-level policy should not care about these things.</p>
<p>• It is not necessary to adopt a dependency injection framework early in
development, because the high-level policy should not care how dependencies are
resolved.  <em>A good architect pretends that the desicion has not been made and,
and shapes the system such that those desision can still be deferred or changed
for as long time as possible.</em></p>
<p><em>A good architect maximize the number of decisions not made</em></p>
<h2 id="conclusion-good-architects-carefully-separate-details-from-policy-and-then"><a class="header" href="#conclusion-good-architects-carefully-separate-details-from-policy-and-then">Conclusion Good architects carefully separate details from policy, and then</a></h2>
<p>decouple the policy from the details so thoroughly that the policy has no
knowledge of the details and does not depend on the details in any way. Good
architects design the policy so that decisions about the details can be delayed
and deferred as long as possible.</p>
<h1 id="independence"><a class="header" href="#independence">Independence</a></h1>
<p>(<em>I think this chapter is very important so most of it won't be a summary but an
exact copy</em>)</p>
<h2 id="use-cases-the-first-bulletuse-casesmeans-that-the-architecture-of-the"><a class="header" href="#use-cases-the-first-bulletuse-casesmeans-that-the-architecture-of-the">Use Cases The first bullet—use cases—means that the architecture of the</a></h2>
<p>system must support the intent of the system. If the system is a shopping cart
application, then the architecture must support shopping cart use cases.
Indeed, this is the first concern of the architect, and the first priority of
the architecture. The architecture must support the use cases. </p>
<p>However, as we discussed previously, architecture does not wield much influence
over the behavior of the system. There are very few behavioral options that the
architecture can leave open. But influence isn't everything. The most important
thing a good architecture can do to support behavior is to clarify and expose
that behavior so that the intent of the system is visible at the architectural
level.</p>
<p>A shopping cart application with a good architecture will look like a shopping
cart application. The use cases of that system will be plainly visible within
the structure of that system. Developers will not have to hunt for behaviors,
because those behaviors will be first-class elements visible at the top level of
the system. Those elements will be classes or functions or modules that have
prominent positions within the architecture, and they will have names that
clearly describe their function. </p>
<h2 id="operation-1"><a class="header" href="#operation-1">Operation</a></h2>
<p>Architecture plays a more substantial, and less cosmetic, role in supporting the
operation of the system. If the system must support 100,000 customers per
second, the architecture must support that.</p>
<p>For some systems, this will mean arranging the processing elements of the system
into an array of little services can be run in parallel on many different
servers. For other systems, it will mean a plethora of little lightweight
threads sharing the address space of a single process within a single processor.
Still other systems will need just a few processes running in isolated address
spaces. And some systems can even survive as simple monolithic programs running
in a single process. </p>
<p>As strange as it may seem, this decision is one of the options that a good
architect leaves open. A system that is written as a monolith, and that depends
on that monolithic structure, cannot easily be upgraded to multiple processes,
multiple threads, or micro-services should the need arise. By comparison, an
architecture that maintains the proper isolation of its components, and does not
assume the means of communication between those components, will be much easier
to transition through the spectrum of threads, processes, and services as the
operational needs of the system change over time.</p>
<h2 id="development-1"><a class="header" href="#development-1">Development</a></h2>
<p>Architecture plays  a significant role in supporting the development
environment.  Conway's law come into play here:</p>
<p><em>Any organization that designs a system will produce a design whose structure is
a copy of the organization's communication structure.</em></p>
<h2 id="deployment-1"><a class="header" href="#deployment-1">Deployment</a></h2>
<p>The goal is “immediate deployment.&quot; A good architecture does not rely on dozens
of little configuration scripts and property file tweaks. It does not require
manual creation of directories or files that must be arranged just so. A good
architecture helps the system to be immediately deployable after build.</p>
<h2 id="leaving-options-open"><a class="header" href="#leaving-options-open">Leaving options open</a></h2>
<p>A good architecture balances all of these concerns with a component structure
that mutually satisfies them all. Sounds easy, right? Well, it's easy for me to
write that. The reality is that achieving this balance is pretty hard. The
problem is that most of the time we don't know what all the use cases are, nor
do we know the operational constraints, the team structure, or the deployment
requirements. Worse, even if we did know them, they will inevitably change
as the system moves through its life cycle. In short, the goals we must meet
are indistinct and inconstant. Welcome to the real world. </p>
<p>A good architecture makes the system easy to change, in all the ways that it
must change, by leaving options open.</p>
<h2 id="decoupling-layers"><a class="header" href="#decoupling-layers">Decoupling Layers</a></h2>
<p>Consider the use cases. The architect wants the structure of the system to
support all the necessary use cases, but does not know what all those use cases
are. However, the architect does know the basic intent of the system. It's a
shopping cart system, or it's a bill of materials system, or it's an order
processing system. So the architect can employ the Single Responsibility
Principle and the Common Closure Principle to separate those things that change
for different reasons, and to collect those things that change for the same
reasons—given the context of the intent of the system. </p>
<p>What changes for different reasons? There are some obvious things. User
interfaces change for reasons that have nothing to do with business rules. Use
cases have elements of both. Clearly, then, a good architect will want to
separate the UI portions of a use case from the business rule portions in such a
way that they can be changed independently of each other, while keeping those
use cases visible and clear. </p>
<p>Business rules themselves may be closely tied to the application, or they may be
more general. For example, the validation of input fields is a business rule
that is closely tied to the application itself. In contrast, the calculation of
interest on an account and the counting of inventory are business rules that are
more closely associated with the domain. These two different kinds of rules will
change at different rates, and for different reasons—so they should be separated
so that they can be independently changed.</p>
<p>The database, the query language, and even the schema are technical details that
have nothing to do with the business rules or the UI. They will change at rates,
and for reasons, that are independent of other aspects of the system.
Consequently, the architecture should separate them from the rest of the system
so that they can be independently changed.</p>
<p>Thus we find the system divided into decoupled horizontal layers—the UI,
application-specific business rules, application-independent business rules, and
the database, just to mention a few.</p>
<h2 id="decoupling-use-cases"><a class="header" href="#decoupling-use-cases">Decoupling Use Cases</a></h2>
<p>What else changes for different reasons? The use cases themselves! The use case
for adding an order to an order entry system almost certainly will change at a
different rate, and for different reasons, than the use case that deletes an
order from the system. Use cases are a very natural way to divide the
system.</p>
<p>At the same time, use cases are narrow vertical slices that cut through the
horizontal layers of the system. Each use case uses some UI, some
application-specific business rules, some application-independent business
rules, and some database functionality. Thus, as we are dividing the system in
to horizontal layers, we are also dividing the system into thin vertical use
cases that cut through those layers.</p>
<p>To achieve this decoupling, we separate the UI of the add-order use case from
the UI of the delete-order use case. We do the same with the business rules, and
with the database. We keep the use cases separate down the vertical height of
the system.</p>
<p>You can see the pattern here. If you decouple the elements of the system that
change for different reasons, then you can continue to add new use cases without
interfering with old ones. If you also group the UI and database in support of
those use cases, so that each use case uses a different aspect of the UI and
database, then adding new use cases will be unlikely to affect older ones.</p>
<h2 id="decoupling-mode"><a class="header" href="#decoupling-mode">Decoupling mode</a></h2>
<p>Now think of what all that decoupling means for the second bullet: operations.
If the different aspects of the use cases are separated, then those that must
run at a high throughput are likely already separated from those that must run
at a low throughput. If the UI and the database have been separated from the
business rules, then they can run in different servers. Those that require
higher bandwidth can be replicated in many servers.</p>
<p>In short, the decoupling that we did for the sake of the use cases also helps
with operations. However, to take advantage of the operational benefit, the
decoupling must have the appropriate mode. To run in separate servers, the
separated components cannot depend on being together in the same address space
of a processor. They must be independent services, which communicate over a
network of some kind.</p>
<p>Many architects call such components “services&quot; or “micro-services,&quot; depending
upon some vague notion of line count. Indeed, an architecture based on services
is often called a service-oriented architecture. If that nomenclature set off
some alarm bells in your mind, don't worry. I'm not going to tell you that SoA
is the best possible architecture, or that microservices are the wave of the
future. The point being made here is that sometimes we have to separate our
components all the way to the service level. Remember, a good architecture
leaves options open. The decoupling mode is one of those options.</p>
<p>Before we explore that topic further, let's look to the other two bullets.</p>
<p>(<em>Read Independent Develop-Ability and Independent deployability</em>)</p>
<h2 id="duplication"><a class="header" href="#duplication">Duplication</a></h2>
<p>Architects often fall into a trap—a trap that hinges on their fear of
duplication.</p>
<p>Duplication is generally a bad thing in software. We don't like duplicated code.
When code is truly duplicated, we are honor-bound as professionals to reduce and
eliminate it. </p>
<p>But there are different kinds of duplication. There is true duplication, in
which every change to one instance necessitates the same change to every
duplicate of that instance. Then there is false or accidental duplication. If
two apparently duplicated sections of code evolve along different paths—if they
change at different rates, and for different reasons—then they are not true
duplicates. Return to them in a few years, and you'll find that they are very
different from each other. </p>
<p>Now imagine two use cases that have very similar screen structures. The
architects will likely be strongly tempted to share the code for that structure.
But should they? Is that true duplication? Or it is accidental?</p>
<p>Most likely it is accidental. As time goes by, the odds are that those two
screens will diverge and eventually look very different. For this reason, care
must be taken to avoid unifying them. Otherwise, separating them later will be a
challenge.</p>
<p>When you are vertically separating use cases from one another, you will run into
this issue, and your temptation will be to couple the use cases because they
have similar screen structures, or similar algorithms, or similar database
queries and/or schemas. Be careful. Resist the temptation to commit the sin of
knee-jerk elimination of duplication. Make sure the duplication is real.</p>
<p>By the same token, when you are separating layers horizontally, you might notice
that the data structure of a particular database record is very similar to the
data structure of a particular screen view. You may be tempted to simply pass
the database record up to the UI, rather than to create a view model that looks
the same and copy the elements across. Be careful: This duplication is almost
certainly accidental. Creating the separate view model is not a lot of effort,
and it will help you keep the layers properly decoupled.</p>
<h2 id="decoupling-modes-again"><a class="header" href="#decoupling-modes-again">Decoupling Modes (Again)</a></h2>
<p>Back to modes. There are many ways to decouple layers and use cases. They can be
decoupled at the source code level, at the binary code (deployment) level, and
at the execution unit (service) level.</p>
<p>• <strong>Source level</strong>. </p>
<p>We can control the dependencies between source code modules so that changes to
one module do not force changes or recompilation of others (e.g., Ruby Gems).
In this decoupling mode the components all execute in the same address space,
and communicate with each other using simple function calls. There is a single
executable loaded into computer memory. People often call this a monolithic
structure</p>
<p>• <strong>Deployment level</strong>.</p>
<p>We can control the dependencies between deployable units such as jar files,
DLLs, or shared libraries, so that changes to the source code in one module do
not force others to be rebuilt and redeployed. Many of the components may still
live in the same address space, and communicate through function calls. Other
components may live in other processes in the same processor, and communicate
through interprocess communications, sockets, or shared memory. The important
thing here is that the decoupled components are partitioned into independently
deployable units such as jar files, Gem files, or DLLs. </p>
<p>• <strong>Service level</strong>.</p>
<p>We can reduce the dependencies down to the level of data structures, and
communicate solely through network packets such that every execution unit is
entirely independent of source and binary changes to others (e.g., services or
micro-services) </p>
<p>What is the best mode to use? The answer is that it's hard to know which mode is
best during the early phases of a project. Indeed, as the project matures, the
optimal mode may change.</p>
<p>For example, it's not difficult to imagine that a system that runs comfortably
on one server right now might grow to the point where some of its components
ought to run on separate servers. While the system runs on a single server, the
source-level decoupling might be sufficient. Later, however, it might require
decoupling into deployable units, or even services.</p>
<p>One solution (which seems to be popular at the moment) is to simply decouple at
the service level by default. A problem with this approach is that it is
expensive and encourages coarse-grained decoupling. No matter how “micro&quot; the
micro-services get, the decoupling is not likely to be fine-grained enough.</p>
<p><strong>My preference is to push the decoupling to the point where a service could be
formed. should it become necessary; but then to leave the components in the same
address space as long as possible. This leaves the option for a service open.</strong></p>
<p>A good architecture will allow a system to be born as a monolith, deployed in a
single file, but then to grow into a set of independently deployable units, and
then all the way to independent services and/or micro-services. Later, as things
change, it should allow for reversing that progression and sliding all the way
back down into a monolith.</p>
<h1 id="boundaries-drawing-lines"><a class="header" href="#boundaries-drawing-lines">Boundaries: Drawing Lines</a></h1>
<p>Software architecture is the art of drawing lines that I call boundaries. Some
of those lines are drawn very early in a project's life—even before any code is
written. Others are drawn much later. Those that are drawn early are drawn for
the purposes of deferring decisions for as long as possible, and of keeping
those decisions from polluting the core business logic.</p>
<p>Recall that the goal of an architect is to minimize the human resources required
to build and maintain the required system. What it is that saps this kind of
people-power? Coupling—and especially coupling to premature decisions.</p>
<p>Which kinds of decisions are premature? Decisions that have nothing to do with
the business requirements—the use cases—of the system. These include decisions
about frameworks, databases, web servers, utility libraries, dependency
injection, and the like. A good system architecture is one in which decisions
like these are rendered ancillary and deferrable. A good system architecture
does not depend on those decisions. A good system architecture allows those
decisions to be made at the latest possible moment, without significant impact.</p>
<h2 id="which-lines-do-you-draw-and-when-do-you-draw-them"><a class="header" href="#which-lines-do-you-draw-and-when-do-you-draw-them">Which Lines Do You Draw, and When Do You Draw Them?</a></h2>
<p>You draw lines between things that matter and things that don't. The GUI doesn't
matter to the business rules, so there should be a line between them.  The
database doesn't matter to the GUI, so there should be a line between them.  The
database doesn't matter to the business rules, so there should be a line between
them.</p>
<p>The classes and interfaces in this diagram are symbolic. In a real application,
there would be many business rule classes, many database interface classes, and
many database access implementations. All of them, though, would follow roughly
the same pattern.</p>
<p><img src="tech/notes/software-arch/../img/db_boundaries.png" alt="Database Boundaries" /></p>
<p>Note the two arrows leaving the <em>DatabaseAccess</em> class. Those two arrows point
away from the <em>DatabaseAccess</em> class. That means that none of these classes
knows that the <em>DatabaseAccess</em> class exists.  The <em>BusinessRules</em> do not know
about the Database. This implies that the <em>DatabaseInterface</em> classes live in
the <em>BusinessRules</em> component, while the <em>DatabaseAccess</em> classes live in the
Database component.</p>
<h2 id="plugin-architecture"><a class="header" href="#plugin-architecture">Plugin Architecture</a></h2>
<p>The history history of software development technology is the story of how to
conveniently create plugins to establish a scalable and maintainable system
architecture. The core business rules are kept separate from, and independent
of, those components that are either optional or that can be implemented in many
different forms <img src="tech/notes/software-arch/../img/plugin_arch.png" alt="Plugin Arq" /> Because the user
interface in this design is considered to be a plugin, we have made it possible
to plug in many different kinds of user interfaces. They could be web based,
client/server based, SOA based, Console based, or based on any other kind of
user interface technology </p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>To draw boundary lines in a software architecture, you first partition the
system into components. Some of those components are core business rules; others
are plugins that contain necessary functions that are not directly related to
the core business. Then you arrange the code in those components such that the
arrows between them point in one direction—toward the core business.</p>
<p>You should recognize this as an application of the Dependency Inversion
Principle and the Stable Abstractions Principle. Dependency arrows are arranged
to point from lower-level details to higher-level abstractions. </p>
<h2 id="boundary-anatomy"><a class="header" href="#boundary-anatomy">Boundary Anatomy</a></h2>
<p>The architecture of a system is defined by a set of software components and the
boundaries that separate them. Those boundaries come in many different forms.
In this chapter we'll look at some of the most common.</p>
<h2 id="boundary-crossing"><a class="header" href="#boundary-crossing">Boundary crossing</a></h2>
<p>At runtime, a boundary crossing is nothing more than a function on one side of
the boundary calling a function on the other side and passing along some data.
The trick to creating an appropriate boundary crossing is to manage the source
code dependencies.</p>
<h2 id="the-dreaded-monolith"><a class="header" href="#the-dreaded-monolith">The dreaded monolith</a></h2>
<p>The simplest and most common of the architectural boundaries has no strict
physical representation. It is simply a disciplined segregation of functions and
data within a single processor and a single address space. In a previous
chapter, I called this the source-level decoupling mode.</p>
<p>The fact that the boundaries are not visible during the deployment of a monolith
does not mean that they are not present and meaningful. Even when statically
linked into a single executable, the ability to independently develop and
marshal the various components for final assembly is immensely valuable. </p>
<p>Such architectures almost always depend on some kind of dynamic polymorphism to
manage their internal dependencies. This is one of the reasons that
object-oriented development has become such an important paradigm in recent
decades.</p>
<p>The simplest possible boundary crossing is a function call from a low-level
client to a higher-level service. Both the runtime dependency and the
compile-time dependency point in the same direction, toward the higher-level
component.</p>
<p>Even in a monolithic, statically linked executable, this kind of disciplined
partitioning can greatly aid the job of developing, testing, and deploying the
project. Teams can work independently of each other on their own components
without treading on each other's toes. High-level components remain independent
of lower-level details.</p>
<p>Communications between components in a monolith are very fast and inexpensive.
They are typically just function calls. Consequently, communications across
source-level decoupled boundaries can be very chatty. Since the deployment of
monoliths usually requires compilation and static linking, components in these
systems are typically delivered as source code.</p>
<h2 id="deployments-components"><a class="header" href="#deployments-components">Deployments components</a></h2>
<p>Deployment does not involve compilation. Instead, the components are delivered
in binary, or some equivalent deployable form. This is the deployment-level
decoupling mode. The act of deployment is simply the gathering of these
deployable units together in some convenient form, such as a WAR file, or even
just a directory.</p>
<p>With that one exception, deployment-level components are the same as monoliths.
The functions generally all exist in the same processor and address space. The
strategies for segregating the components and managing their dependencies are
the same.</p>
<h2 id="threads"><a class="header" href="#threads">Threads</a></h2>
<p>Both monoliths and deployment components can make use of threads. Threads are
not architectural boundaries or units of deployment, but rather a way to
organize the schedule and order of execution. They may be wholly contained
within a component, or spread across many components.</p>
<h2 id="local-processes"><a class="header" href="#local-processes">Local Processes</a></h2>
<p>A much stronger physical architectural boundary is the local process. A local
process is typically created from the command line or an equivalent system call.
Local processes run in the same processor, or in the same set of processors
within a multicore, but run in separate address spaces. Memory protection
generally prevents such processes from sharing memory, although shared memory
partitions are often used.</p>
<p>Most often, local processes communicate with each other using sockets, or some
other kind of operating system communications facility such as mailboxes or
message queues. Each local process may be a statically linked monolith, or it
may be composed of dynamically linked deployment components.</p>
<p>Think of a local process as a kind of uber-component: The process consists of
lower-level components that manage their dependencies through dynamic
polymorphism </p>
<p>Communication across local process boundaries involve operating system calls,
data marshaling and decoding, and interprocess context switches, which are
moderately expensive. Chattiness should be carefully limited</p>
<h2 id="service"><a class="header" href="#service">Service</a></h2>
<p>The strongest boundary is a service. A service is a process, generally started
from the command line or through an equivalent system call. Services do not
depend on their physical location. Communications across service boundaries are
very slow compared to function calls. </p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Most systems, other than monoliths, use more than one boundary strategy. A
system that makes use of service boundaries may also have some local process
boundaries. Indeed, a service is often just a facade for a set of interacting
local processes. A service, or a local process, will almost certainly be either
a monolith composed of source code components or a set of dynamically linked
deployment components.</p>
<p>This means that the boundaries in a system will often be a mixture of local
chatty boundaries and boundaries that are more concerned with latency </p>
<h1 id="policy-and-level"><a class="header" href="#policy-and-level">Policy and Level</a></h1>
<p>Policies that change for different reasons, or at different times, are at
different levels and should be separated into different components.</p>
<p>In a good architecture, the direction of those dependencies is based on the
level of the components that they connect. In every case, low-level components
are designed so that they depend on high-level components.</p>
<p>A strict definition of “level&quot; is “the distance from the inputs and outputs.&quot;
The farther a policy is from both the inputs and the outputs of the system, the
higher its level.</p>
<h1 id="business-rules"><a class="header" href="#business-rules">Business Rules</a></h1>
<p>Strictly speaking, business rules are rules or procedures that make or save the
business money. Very strictly speaking, these rules would make or save the
business money, irrespective of whether they were implemented on a computer.
They would make or save money even if they were executed manually.The fact that
a bank charges N% interest for a loan is a business rule that</p>
<p>We shall call these rules Critical Business Rules, because they are critical to
the business itself, and would exist even if there were no system to automate
them. Critical Business Rules usually require some data to work with. For
example, our loan requires a loan balance, an interest rate, and a payment
schedule. We shall call this data Critical Business Data. This is the data that
would exist even if the system were not automated.The critical rules and
critical data are inextricably bound, so they are a good </p>
<h2 id="entity"><a class="header" href="#entity">Entity</a></h2>
<p>An Entity is an object within our computer system that embodies a small set of
critical business rules operating on Critical Business Data.</p>
<p>You don't need to use an object-oriented language to create an Entity. All that
is required is that you bind the Critical Business Data and the Critical
Business </p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>A use case is a description of the way that an automated system is used. It
specifies the input to be provided by the user, the output to be returned to the
user, and the processing steps involved in producing that output. A use case
describes application-specific business rules as opposed to the Critical
Business Rules within the Entities.</p>
<p>Use cases contain the rules that specify how and when the Critical Business
Rules within the Entities are invoked. Use cases control the dance of the
Entities.</p>
<p>From the use case, it is impossible to tell whether the application is delivered
on the web, or on a thick client, or on a console, or is a pure service.</p>
<p>This is very important. Use cases do not describe how the system appears to the
user. Instead, they describe the application-specific rules that govern the
interaction between the users and the Entities. </p>
<p>A use case is an object. It has one or more functions that implement the
application-specific business rules. </p>
<p>Why are Entities high level and use cases lower level? Because use cases are
specific to a single application and, therefore, are closer to the inputs and
outputs of that system.</p>
<h1 id="screaming-architecture"><a class="header" href="#screaming-architecture">Screaming Architecture</a></h1>
<p>So what does the architecture of your application scream? When you look at the
top-level directory structure, and the source files in the highest-level
package, do they scream “Health Care System,&quot; or “Accounting System,&quot; or
“Inventory Management System&quot;? Or do they scream “Rails,&quot; or “Spring/Hibernate,&quot;
or “ASP&quot;?</p>
<h2 id="the-theme-of-an-architecture"><a class="header" href="#the-theme-of-an-architecture">The Theme of an architecture</a></h2>
<p>Architectures are not (or should not be) about frameworks. Architectures should
not be supplied by frameworks. Frameworks are tools to be used, not
architectures to be conformed to. If your architecture is based on frameworks,</p>
<h2 id="the-purpose-of-an-architecture"><a class="header" href="#the-purpose-of-an-architecture">The purpose of an architecture</a></h2>
<p>Good architectures are centered on use cases so that architects can safely
describe the structures that support those use cases without committing to
frameworks, tools, and environments.</p>
<h2 id="but-what-about-the-web-"><a class="header" href="#but-what-about-the-web-">But what about the web ?</a></h2>
<p>Is the web an architecture? Does the fact that your system is delivered on the
web dictate the architecture of your system? Of course not! The web is a
delivery mechanism—an IO device—and your application architecture should treat
it as such.</p>
<h2 id="frameworks-are-tools-not-ways-of-life"><a class="header" href="#frameworks-are-tools-not-ways-of-life">Frameworks are tools not ways of life</a></h2>
<p>Frameworks can be very powerful and very useful. Framework authors often believe
very deeply in their frameworks. The examples they write for how to use their
frameworks are told from the point of view of a true believer. Other authors who
write about the framework also tend to be disciples of the true belief. They
show you the way to use the framework. Often they assume an all-encompassing,
all-pervading, let-the-framework-do-everything position.</p>
<p>This is not the position you want to take.</p>
<h2 id="testable-architecture"><a class="header" href="#testable-architecture">Testable Architecture</a></h2>
<p>If your system architecture is all about the use cases, and if you have kept
your frameworks at arm's length, then you should be able to unit-test all those
use cases without any of the frameworks in place. You shouldn't need the web
server running to run your tests. You shouldn't need the database connected to
run your tests. </p>
<h1 id="the-clean-architecture"><a class="header" href="#the-clean-architecture">The Clean Architecture</a></h1>
<p>Although these architectures all vary somewhat in their details, they are very
similar. They all have the same objective, which is the separation of concerns.
Each of these architectures produces systems that have the following
characteristics:</p>
<ul>
<li>Independent of frameworks. The architecture does not depend on the existence
of some library of feature-laden software. This allows you to use such
frameworks as tools, rather than forcing you to cram your system into their
limited constraints.</li>
<li>Testable. The business rules can be tested without the UI, database, web
server, or any other external element.</li>
<li>Independent of the UI. The UI can change easily, without changing the rest of
the system. A web UI could be replaced with a console UI, for example, without
changing the business rules.</li>
<li>Independent of the database. You can swap out Oracle or SQL Server for Mongo,
BigTable, CouchDB, or something else. Your business rules are not bound to the
database.</li>
<li>Independent of any external agency. In fact, your business rules don't know
anything at all about the interfaces to the outside world.</li>
</ul>
<p><img src="tech/notes/software-arch/../img/CleanArchitecture.jpg" alt="Clean Arch" /></p>
<h2 id="the-dependency-rule"><a class="header" href="#the-dependency-rule">The dependency rule</a></h2>
<p><em>Source code dependencies must point only inward, toward higher-level policies.</em></p>
<p>Nothing in an inner circle can know anything at all about something in an outer
circle. In particular, the name of something declared in an outer circle must
not be mentioned by the code in an inner circle. That includes functions,
classes, variables, or any other named software entity. </p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Entities encapsulate enterprise-wide Critical Business Rules. An entity can be
an object with methods, or it can be a set of data structures and functions. It
doesn't matter so long as the entities can be used by many different
applications in the enterprise.</p>
<p>If you don't have an enterprise and are writing just a single application, then
these entities are the business objects of the application. They encapsulate the
most general and high-level rules. </p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>The software in the use cases layer contains application-specific business
rules. It encapsulates and implements all of the use cases of the system. These
use cases orchestrate the flow of data to and from the entities, and direct
those entities to use their Critical Business Rules to achieve the goals of the
use case.</p>
<p>Changes to the operation of the application will affect the use cases and,
therefore, the software in this layer. If the details of a use case change, then
some code in this layer will certainly be affected.</p>
<p>Similarly, data is converted, in this layer, from the form most convenient for
entities and use cases, to the form most convenient for whatever persistence
framework is being used (i.e., the database).</p>
<h2 id="framework-and-drivers"><a class="header" href="#framework-and-drivers">Framework and drivers</a></h2>
<p>Frameworks and tools such as the database and the web framework. Generally you
don't write much code in this layer, other than glue code that communicates to
the next circle inward.</p>
<h2 id="crossing-boundaries"><a class="header" href="#crossing-boundaries">Crossing Boundaries</a></h2>
<p>The same technique is used to cross all the boundaries in the architectures. We
take advantage of dynamic polymorphism to create source code dependencies that
oppose the flow of control so that we can conform to the Dependency Rule, no
matter which</p>
<h2 id="which-data-crosses-the-boundaries"><a class="header" href="#which-data-crosses-the-boundaries">Which data crosses the boundaries</a></h2>
<p>You can use basic structs or simple data transfer objects if you like. Or the
data can simply be arguments in function calls. Or you can pack it into a
hashmap, or construct it into an object. The important thing is that isolated,
simple data structures are passed across the boundaries. We don't want to cheat
and pass Entity objects or database rows. We don't want the data structures to
have any kind of dependency that violates the Dependency Rule.  Thus, when we
pass data across a boundary, it is always in the form that is most convenient
for the inner circle.</p>
<h2 id="the-humble-object-pattern"><a class="header" href="#the-humble-object-pattern">The humble object pattern</a></h2>
<p>The Humble Object pattern1 is a design pattern that was originally identified as
a way to help unit testers to separate behaviors that are hard to test from
behaviors that are easy to test. The idea is very simple: Split the behaviors
into two modules or classes. One of those modules is humble; it contains all the
hard-to-test behaviors stripped down to their barest essence. The other module
contains all the testable behaviours that were stripped out of the humble
object. </p>
<h2 id="database-gateways"><a class="header" href="#database-gateways">Database Gateways</a></h2>
<p>Between the use case interactors and the database are the database gateways.2
These gateways are polymorphic interfaces that contain methods for every create,
read, update, or delete operation that can be performed by the application on
the database. For example, if the application needs to know the last names of
all the users who logged in yesterday, then the UserGateway interface will have
a method named getLastNamesOfUsersWhoLoggedInAfter that takes a Date as its
argument and returns a list of last names.</p>
<p>Recall that we do not allow SQL in the use cases layer; instead, we use gateway
interfaces that have appropriate methods. Those gateways are implemented by
classes in the database layer. That implementation is the humble object. It
simply uses SQL, or whatever the interface to the database is, to access the
data required by each of the methods. The interactors, in contrast, are not
humble because they encapsulate application-specific business rules. Although
they are not humble, those interactors are testable, because the gateways can be
replaced with appropriate stubs</p>
<h2 id="data-mappers"><a class="header" href="#data-mappers">Data Mappers</a></h2>
<p>There is no such thing as an object relational mapper (ORM). The reason is
simple: Objects are not data structures. At least, they are not data structures
from their users' point of view. The users of an object cannot see the data,
since it is all private. Those users see only the public methods of that object.
So, from the user's point of view, an object is simply a set of operations.</p>
<p>A data structure, in contrast, is a set of public data variables that have no
implied behavior. ORMs would be better named “data mappers,&quot; because they load
data into  Where should such ORM systems reside? In the database layer of
course.</p>
<h2 id="service-listeners"><a class="header" href="#service-listeners">Service Listeners</a></h2>
<p>What about services? If your application must communicate with other services,
or if your application provides a set of services, will we find the Humble
Object pattern creating a service boundary? </p>
<p>Of course! The application will load data into simple data structures and then
pass those structures across the boundary to modules that properly format the
data and send it to external services.</p>
<p>At each architectural boundary, we are likely to find the Humble Object pattern
lurking somewhere nearby.</p>
<h1 id="partial-boundaries"><a class="header" href="#partial-boundaries">Partial Boundaries</a></h1>
<h2 id="skip-the-last-step"><a class="header" href="#skip-the-last-step">Skip the last step</a></h2>
<p>One way to construct a partial boundary is to do all the work necessary to
create independently compilable and deployable components, and then simply keep
them together in the same component. The reciprocal interfaces are there, the
input/output data structures are there, and everything is all set up—but we
compile and deploy all</p>
<h2 id="one-dimensional-boundaries"><a class="header" href="#one-dimensional-boundaries">One-dimensional boundaries</a></h2>
<p>The full-fledged architectural boundary uses reciprocal boundary interfaces to
maintain isolation in both directions. Maintaining separation in both directions
is expensive both in initial setup and in ongoing maintenance. </p>
<h2 id="facades"><a class="header" href="#facades">Facades</a></h2>
<p>An even simpler boundary is the Facade pattern. In this case, even the
dependency inversion is sacrificed. The boundary is simply defined by</p>
<p>Clean Architecture: That means that there is a potential architectural boundary
defined by this axis of change</p>
<p>So what do we do, we architects? The answer is dissatisfying. On the one hand,
some very smart people have told us, over the years, that we should not
anticipate the need for abstraction. This is the philosophy of YAGNI: “You
aren't going to need it.&quot; There is wisdom in this message, since
over-engineering is often much worse than under-engineering. On the other hand,
when you discover that you truly do need an architectural boundary where none
exists, the costs and risks can be very high to add such a boundary.</p>
<p>But this is not a one-time decision. You don't simply decide at the start of a
project which boundaries to implement and which to ignore. Rather, you watch.
You pay attention as the system evolves. You note where boundaries may be
required, and then carefully watch for the first inkling of friction because
those boundaries don't exist.</p>
<h1 id="the-main-component"><a class="header" href="#the-main-component">The main component</a></h1>
<p>In every system, there is at least one component that creates, coordinates, and
oversees the others. I call this component Main.</p>
<p>Its job is to create all the Factories, Strategies, and other global facilities,
and then hand control over to the high-level abstract portions of the system.
It is in this Main component that dependencies should be injected by a
Dependency</p>
<p>Injection framework. Once they are injected into Main, Main should distribute
those dependencies normally, without using the framework.</p>
<p>Think of Main as the dirtiest of all the dirty components.</p>
<p>Think of Main as a plugin to the application—a plugin that sets up the initial
conditions and configurations, gathers all the outside resources, and then hands
control over to the high-level policy of the application. Since it is a plugin,
it is possible to have many Main components, one for each configuration of your
application. </p>
<p>For example, you could have a Main plugin for Dev, another for Test, and yet
another for Production. You could also have a Main plugin for each country you
deploy to, or each jurisdiction, or each customer. </p>
<p>When you think about Main as a plugin component, sitting behind an architectural
boundary, the problem of configuration becomes a lot easier to solve.</p>
<h1 id="services-great-and-small-service-oriented-architectures-and-micro-service"><a class="header" href="#services-great-and-small-service-oriented-architectures-and-micro-service">Services: Great and small Service-oriented “architectures&quot; and micro-service</a></h1>
<p>“architectures&quot; have become very popular of late. The reasons for their current
popularity include the following:</p>
<ul>
<li>
<p>Services seem to be strongly decoupled from each other. As we shall see, this
is only partially true.</p>
</li>
<li>
<p>Services appear to support independence of development and deployment. Again,</p>
</li>
</ul>
<p>Services that simply separate application behaviors are little more than
expensive function calls, and are not necessarily architecturally significant.</p>
<p>This is not to say that all services should be architecturally significant.
There are often substantial benefits to creating services that separate
functionality across processes and platforms—whether they obey the Dependency
Rule or not. It's just that services, in and of themselves, do not define an
architecture. </p>
<h2 id="the-decoupling-fallacy"><a class="header" href="#the-decoupling-fallacy">The decoupling fallacy</a></h2>
<p>One of the big supposed benefits of breaking a system up into services is that
services are strongly decoupled from each other. After all, each service runs in
a</p>
<p>There is certainly some truth to this—but not very much truth. Yes, services are
decoupled at the level of individual variables. However, they can still be
coupled by shared resources within a processor, or on the network. What's more,
they are strongly coupled by the data they share.</p>
<p>For example, if a new field is added to a data record that is passed between
services, then every service that operates on the new field must be changed.</p>
<p>Service interfaces are no more formal, no more rigorous, and no better defined
than function interfaces. Clearly, then, this benefit is something of an
illusion. </p>
<p>First, history has shown that large enterprise systems can be built from
monoliths and component-based systems as well as service-based systems. Thus
services are not the only option for building scalable systems.</p>
<p>Yes! Services do not need to be little monoliths. Services can, instead, be
designed using the SOLID principles, and given a component structure so that new
components can be added to them without changing the existing components within
the service.</p>
<p>The services still exist as before, but each has its own internal component
design, allowing new features to be added as new derivative classes. Those
derivative classes live within their own </p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-cutting concerns</a></h2>
<p>What we have learned is that architectural boundaries do not fall between
services. Rather, those boundaries run through the services, dividing them into
components.</p>
<p>Those services do not define the architectural boundaries of the system;
instead, the components within the services</p>
<p>As useful as services are to the scalability and develop-ability of a system,
they are not, in and of themselves, architecturally significant elements.</p>
<p>A service might be a single component, completely surrounded by an architectural
boundary. Alternatively, a service might be composed of several components
separated by architectural boundaries. In rare2 cases, clients and services may
be so coupled as to have no architectural sig </p>
<h2 id="the-test-boundary"><a class="header" href="#the-test-boundary">The test boundary</a></h2>
<p>From an architectural point of view, all tests are the same.</p>
<p>Tests are the most isolated system component. They are not necessary for system
operation. No user depends on them. Their role is to support development, not
operation. And yet, they are no less a system component than any other. In fact,
in many ways they represent the model that all other system components should
follow.</p>
<h2 id="design-for-testability"><a class="header" href="#design-for-testability">Design for testability</a></h2>
<p>The extreme isolation of the tests, combined with the fact that they are not
usually deployed, often causes developers to think that tests fall outside of
the design of the system. This is a catastrophic point of view. Tests that are
not well integrated into the design of the system tend to be fragile, and they
make the system rigid and difficult to change. </p>
<h1 id="clean-embedded-architecture"><a class="header" href="#clean-embedded-architecture">Clean embedded architecture</a></h1>
<p>Software is this thing that can have a long useful life, but firmware will
become obsolete as hardware evolves.  Non-embedded engineers also write
firmware! You non-embedded developers essentially write firmware whenever you
bury SQL in your code or when you spread platform dependencies throughout your
code.</p>
<h2 id="app-titude-test"><a class="header" href="#app-titude-test">App-titude test</a></h2>
<p>Why does so much potential embedded software become firmware? </p>
<ol>
<li>“First make it work.&quot; You are out of business if it doesn't work.</li>
<li>“Then make it right.&quot; Refactor the code so that you and others can understand
it and evolve it as needs change or are better understood.</li>
<li>“Then make it fast.&quot; Refactor the code for “needed&quot; performance.</li>
</ol>
<h2 id="programming-to-interfaces-and-substitutability"><a class="header" href="#programming-to-interfaces-and-substitutability">Programming to interfaces and substitutability</a></h2>
<p>The idea of a layered architecture is built on the idea of programming to
interfaces. When one module interacts with another though an interface, you can
substitute one service provider for another. Many readers will have written
their own small version of printf for deployment in the target. As long as the
interface to your printf is the same as the standard version of printf, you can
override the service one for the other.</p>
<h1 id="the-database-is-a-detail"><a class="header" href="#the-database-is-a-detail">The database is a detail</a></h1>
<p>From an architectural point of view, the database is a non-entity—it is a detail
that does not rise to the level of an architectural element.</p>
<p>The structure you give to the data within your application is highly significant
to the architecture of your system. But the database is not the data model. The
database is piece of software. The database is a utility that provides access to
the data.</p>
<h2 id="relational-databases"><a class="header" href="#relational-databases">Relational databases</a></h2>
<p>The relational model is elegant, disciplined, and robust.</p>
<p>While relational tables may be convenient for certain forms of data access,
there is nothing architecturally significant about arranging data into rows
within tables. The</p>
<p>To mitigate the time delay imposed by disks, you need indexes, caches, and
optimized query schemes.</p>
<p>Over the years these systems have split into two distinct kinds: file systems
and relational database management systems (RDBMS). </p>
<p>File systems are document based. They provide a natural and convenient way to
store whole documents. They work well when you need to save and retrieve a set
of documents by name, but they don't offer a lot of help when you're searching
the content of those documents. It's easy to find a file named login.c, but it's
hard, and slow, to find every .c file that has a variable named x in it.</p>
<p>Database systems are content based. They provide a natural and convenient way to
find records based on their content. They are very good at associating multiple
records based on some bit of content that they all share.  Unfortunately, they
are rather poor at storing and retrieving opaque documents. </p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Isn't performance an architectural concern? Of course it is—but when it comes to
data storage, it's a concern that can be entirely encapsulated and separated
from the business rules. </p>
<h1 id="the-web-is-a-detail"><a class="header" href="#the-web-is-a-detail">The web is a detail</a></h1>
<p>The web is just the latest in a series of oscillations that our industry has
gone through since the 1960s. </p>
<p>The upshot is simply this: The GUI is a detail. The web is a GUI. So the web is
a detail. And, as an architect, you want to put details like that behind
boundaries that keep them separate from your core business logic. </p>
<h1 id="frameworks-are-a-details"><a class="header" href="#frameworks-are-a-details">Frameworks are a details</a></h1>
<p>Frameworks are not architectures—though some try to be.</p>
<h2 id="asymmetric-marriage"><a class="header" href="#asymmetric-marriage">Asymmetric Marriage</a></h2>
<p>The relationship between you and the framework author is extraordinarily
asymmetric. You must make a huge commitment to the framework, but the framework
author makes no commitment to you whatsoever. </p>
<h1 id="the-missing-chapter"><a class="header" href="#the-missing-chapter">The missing chapter</a></h1>
<p>All of the advice you've read so far will certainly help you design better
software, composed of classes and components with well-defined boundaries, clear
responsibilities, and controlled dependencies. But it turns out that the devil
is in the implementation details, and it's really easy to fall at the last
hurdle if you don't give </p>
<h2 id="package-by-layer"><a class="header" href="#package-by-layer">Package by layer</a></h2>
<p>The first, and perhaps simplest, design approach is the traditional horizontal
layered architecture, where we separate our code based on what it does from a
technical</p>
<p>The first, and perhaps simplest, design approach is the traditional horizontal
layered architecture, where we separate our code based on what it does from a
technical perspective. This is often called “package by layer.&quot; </p>
<p>In this typical layered architecture, we have one layer for the web code, one
layer for our “business logic,&quot; and one layer for persistence. In other words,
code is sliced horizontally into layers, which are used as a way to group
similar types of things. In a “strict layered architecture,&quot; layers should
depend only on the next adjacent lower layer.</p>
<h2 id="package-by-feature"><a class="header" href="#package-by-feature">Package by feature</a></h2>
<p>This is a vertical slicing, based on related features, domain concepts, or
aggregate roots (to use domain-driven design terminology). </p>
<h2 id="ports-and-adapters"><a class="header" href="#ports-and-adapters">Ports and adapters</a></h2>
<p>As Uncle Bob has said, approaches such as “ports and adapters,&quot; the “hexagonal
architecture,&quot; “boundaries, controllers, entities,&quot; and so on aim to create
architectures where business/domain-focused code is independent and separate
from the technical implementation details such as frameworks and databases. </p>
<p>The keen-eyed reader will notice that the OrdersRepository from previous
diagrams has been renamed to simply be Orders. This comes from the world of
domain-driven design, where the advice is that the naming of everything on the
“inside&quot; should be stated in terms of the “ubiquitous domain language.&quot; To put
that another way, we talk about “orders&quot; when we're having a discussion about
the domain, not the “orders repository.&quot;</p>
<p>It's also worth pointing out that this is a simplified version of what the UML
class diagram might look like, because it's missing things like interactors and
objects to</p>
<h1 id="conclusion-the-missing-advice"><a class="header" href="#conclusion-the-missing-advice">Conclusion: the missing advice</a></h1>
<p>The whole point of this chapter is to highlight that your best design intentions
can be  destroyed in a flash if you don't consider the intricacies of the
implementation strategy. Think about how to map your desired design on to code
structures, how to organize that code, and which decoupling modes to apply
during runtime and compile-time. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-driven-design"><a class="header" href="#domain-driven-design">Domain Driven Design</a></h1>
<h2 id="quick-ddd-notes"><a class="header" href="#quick-ddd-notes">Quick DDD Notes</a></h2>
<p>This notes have been taken from the free <a href="https://www.goodreads.com/book/show/2558105">Domain Driven Design Quickly
</a>. I highly recommend reading the
book. I have found it to be a concise summary of the <a href="https://www.goodreads.com/en/book/show/179133">original
book</a>. In this summary I will be
just mentioning/listing the best ideas of the all the concepts mentioned in the
book. </p>
<p><strong>Disclaimer:</strong> <em>There is no strict narrative to this post, just useful ideas
written in a sentence or two to Ctrl+F whenever you hesitate before making a
design decision.</em></p>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>The, so called, <strong>Model</strong> is the abstraction of the <strong>Domain</strong>.</p>
<p>The Domain comes to light talking to the <em>Domain Experts</em>, which are the
business experts.</p>
<p>The abstraction is the model. This is not a diagram but the idea that the
diagram is intended to convey.</p>
<p>Sometime the domain contain too much, so we must leave parts out of our model.</p>
<p>We should be able to communicate the Model.</p>
<ul>
<li>Graphical Diagrams</li>
<li>Writing</li>
<li>Language</li>
</ul>
<p>Only once we are sure we can communicate the model we can start to design our
code.</p>
<p><strong>Software Design:</strong> The big pictures, where the walls of a house are going to
be placed.</p>
<p><strong>Code Design:</strong> Detail, where certain painting is going to be hang.</p>
<p>Code design mistakes are easy to correct, the totally opposite happens with
Software design mistakes.</p>
<p><strong>Analysis Paralysis:</strong> Teams members so afraid of making any design decision
that end up making no progress at all.</p>
<h2 id="the-ubiquitous-language"><a class="header" href="#the-ubiquitous-language">The Ubiquitous Language</a></h2>
<p>One different person uses different words when writing than when speaking.
Sometimes, even in the same sentences.</p>
<p>A core principle of DDD is to use a language <strong>based on the model</strong>.</p>
<p>That language and the models are strongly interconnected with one another. A
change in the language is a change in the model.</p>
<p><strong><em>Domain experts should easily understands the both the language and the
model.</em></strong></p>
<p>The language can be expressed in text, diagrams, etc. (UML diagrams are not
recommended by this book)</p>
<h2 id="model-driven-design"><a class="header" href="#model-driven-design">Model Driven Design</a></h2>
<p><strong>Very important details are discovered during the design and implementation
process.</strong> A Model that is truthful to the Domain can turn out to have serious
problems with object persistence, or unacceptable performance behaviour. The
Model should be constructed with an eye open to the software and design
considerations. <strong>Developers should be included in the modeling process</strong>. This
ensures that the model can actually be implemented.</p>
<p>&quot;Procedural programming does not suit well Model driven Design&quot;</p>
<h3 id="the-building-blocks-of-a-model-driven-design"><a class="header" href="#the-building-blocks-of-a-model-driven-design">The building blocks of a Model Driven Design</a></h3>
<p><img src="tech/notes/software-arch/../img/2021-06-22-11-25-26.png" alt="Model Driven Design" /></p>
<h2 id="layered-architecture"><a class="header" href="#layered-architecture">Layered Architecture</a></h2>
<p>A common architectural solution for domain-driven designs contain four
conceptual layers:</p>
<p><strong>User Interface</strong> (Presentation Layer): Responsible for presenting information
to the user and interpreting user commands.</p>
<p><strong>Application Layer:</strong> This is a thin layer which coordinates the application
activity. It does not contain business logic. It does not hold the state of the
business objects, but it can hold the state of an application task progress.</p>
<p><strong>Domain Layer:</strong> This layer contains information about the domain. This is the
heart of the business software. The state of business objects is held here.
Persistence of the business objects and possibly their state is delegated to the
infrastructure layer.</p>
<p><strong>Infrastructure Layer:</strong> This layer acts as a supporting library for all the
other layers. It provides communication between layers, implements persistence
for business objects, contains supporting libraries for the user interface
layer, etc.</p>
<h2 id="entities-1"><a class="header" href="#entities-1">Entities</a></h2>
<p>Entities are necessary objects in the domain model and should be considered from
beginning of the modeling.</p>
<p>An Object must be an Entity as long as it has identity. For these objects is not
the attributes that matter, but the thread of continuity and identity.</p>
<p>Usually the identity is either an attribute of the object, a combination of
attributes or an attribute specially created to preserve and express identity,
or even a behaviour.  The &quot;ID&quot; could be auto generated by a module, could be the
PK of a table in a DB or it could be created by the user.</p>
<p>This means of identification may come from outside or it may be created by and
for the system, bit it must correspond to the identity distinctions in the
model.  The model must define what it means to be the same thing.</p>
<p>Beware of considering all objects entities, there may be performance issues.
(Consider the case of a drawing App explained in the book)</p>
<h2 id="value-objects"><a class="header" href="#value-objects">Value Objects</a></h2>
<p>There are cases where we need to contain some attributes of a domain element we
are not interested in which object it is, but what attributes it has. An object
that is used to describe certain aspects of a domain, and which does not have
identity, is name value object.</p>
<p>It is highly recommendable that these objects are immutable, even more if they
are sharable</p>
<p>Value objects  should stay thin, making a copy of a V.O should be easy.</p>
<p>Value Objects, can contain other value objects, and they can even contain
references to entities. Although V.O attributes of a domain object, that does
not mean that it should contain a long list with all the attributes.  Attributes
can be grouped in different objects. Attributes chosen to make up a V.O should
form a conceptual whole.</p>
<p><img src="tech/notes/software-arch/../img/2021-06-22-15-47-12.png" alt="Value Objects" /></p>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<p>Some aspects of the domain are not easily mapped to objects,. Objects are
generally considered as having attributes, an internal state which is managed by
the object, and exhibit a behaviour.</p>
<p>The nouns of the language are easily mapped to objects, the verbs of the
language become the part of the behaviour of those objects. But there are some
actions in the domain, some verbs, which do not seem to belong to any object.
They represent an important behaviour of the domain, so they cannot be neglected
or simply incorporated to some of the Entities or Value Objects. Nonetheless,
using an OO language, we have to use an object for this purpose. </p>
<p>When such a behaviour is recognized in the domain, the best practice is to
declare it as a Service. Such object does not have an internal state, and it
purpose is to provide functionality to the domain. The Service can group related
functionality which serves Entities and Value Objects. </p>
<p>Services must be declared explicitly, they must encapsulate a concept. We should
not create a Service for each operation needed. But when such an operation
stands out as an important concept in the domain.</p>
<p>A Service is not about the object performing the service, but is related to the
objects the operations are performed on/for. They usually become the point of
connection for many objects.</p>
<p>There are 3 characteristics of a Service:</p>
<ol>
<li>
<p>The operation performed by a Service refers to a domain concept which does
not naturally belong to an Entity or Value Object</p>
</li>
<li>
<p>The operation performed refers to other objects in the domain.</p>
</li>
<li>
<p>The operation is stateless</p>
</li>
</ol>
<p>It is easy to confused services which belongs to the domain and those that
belong to the infrastructure. (To read more about it please refer to the last
part of the &quot;Service&quot; chapter where some examples are provided)</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>The model reaches a point where it is hard to talk about as a whole and
understanding the relationships and interaction between different parts becomes
difficult. For that reason, it is necessary to organize the model into modules.</p>
<p>Using modules in design is a way to increase cohesion and decrease coupling.
Modules should be made up of elements which functionally or logically belongs
together assuring cohesion. Modules should have wall defined interfaces which
are accessed by other modules instead of calling three objects of a module, it
is better to access one interface, because it reduces coupling. Low coupling
reduces complexity, and increases maintainability. It is easier to understand
how a system functions when there are few connections between modules. </p>
<p>It is widely accepted   that software code should have a high level of cohesion
and low level of coupling.</p>
<p>There are several types of cohesion. Two of the most used are <strong>communicational
cohesion</strong> and <strong>functional cohesion</strong> . </p>
<p>Communicational cohesion is achieved when parts of the module operate on the
same data. It makes sense to group the because there is a strong relationship
between them.</p>
<p>Functional cohesion is achieved when all parts of the modules work together to
perform a well-defined task. This is consider the best type of cohesion.</p>
<p>Chose modules that tells the story of the system and contain a cohesive set of
concepts.</p>
<p>Seek low coupling in the sense of concepts that can be understood and reasoned
about independently of each other.</p>
<p>Give the modules names that become part of the Ubiquitous Language. Name of
modules should reflect insights into the domain.</p>
<h2 id="modeling-domain-objects-aggregates"><a class="header" href="#modeling-domain-objects-aggregates">Modeling Domain Objects (Aggregates)?</a></h2>
<p>The last three patterns in this chapter will deal with a different modeling
challenge, one related to the life cycle of domain objects. Domain objects go
through a set of states during their life time. They are created, placed in
memory and used in computations, and they are destroyed. In some cases they are 
saved in permanent locations, like a database, where they can be retrieved from
some time later, or they can be archived.</p>
<p>No matter how much consideration we put in the design, it happens that many
objects are associated with one another, creating a complex net of
relationships. There are several types of associations. For every traversable
association in the model, there has to be corresponding software mechanism which
enforces it. Real associations between domain object end up in the code, and
many times even in the database. A one-to-one relationship between a customer
and the bank account opened on his name is expressed as a reference between two
objects, and implies a relationship between two database tables, the one which
keeps the customers and the one which keeps the accounts.</p>
<p>Most of the time it pays of to eliminate or simplify relations from the model.
That is, unless they embed deep understanding of the domain.</p>
<p>A one-to-many association is more complex because it involves many objects which
become related. This relationship can be simplified by transforming it into an
association between one object and a collection of other objects, although it is
not always </p>
<p>There are many-to-many associations and a large number of theme are
bidirectional. Associations which are not essential for the model should be
removed. They may exist in the domain, but they are not necessary in our model,
so take them out. 
Multiplicity can be reduced by adding a constraint. If many
objects satisfy a relationship, it is possible that only one will do it if the
right constraint is imposed on the relationship.
Many time bidirectional relationships can be transformed in unidirectional ones.</p>
<p>When domain objects are related and any of them changes (deleted, modified, etc.)
the system needs to make sure that is is properly updated throughout the system,
and data integrity is guaranteed. This is usually left to be addressed at
database level. Transactions are used to enforce data integrity.</p>
<p>While database transactions play a vital role in such operations, it is
desirable to solve some of the problems related to data integrity directly in
the model.</p>
<p>It is also necessary to be able to enforce the invariants. The invariants are
those rules which have to be maintained whenever data changes.</p>
<p>Therefore use Aggregates</p>
<h2 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h2>
<p>Aggregate is a domain pattern used to define object ownership and boundaries.
Factories and Repositories are two design patterns which help us deal with
object creation and storage.</p>
<p>An  Aggregate is a group of associated objects which are considered as one unit
with regard to data changes. The Aggregate is demarcated by a boundary which
separated the objects inside from those outside. Each Aggregate has one root.
The root is an Entity, and it is the only object accessible from outside. The
root can hold references to any of the aggregate objects, and the other objects
can hold references to each other, but an outside object can hold references
only to the root object. If there are other Entities inside the boundary, the
identity of those entities is local, making sense only inside the aggregate.</p>
<p>How is the Aggregate ensuring data integrity and enforcing the invariants? Since
other objects can hold references only to the root, it means that they cannot
directly change the other objects in the aggregate. All they can do is to change
the root, or ask the root to perform some actions. And the root will be able to
change the other objects, but that is an operation contained inside the
aggregate, and it is controllable. If the root is deleted and removed from
memory, all the other objects from the aggregate will be deleted too, because
there is no other object holding reference to any of them.</p>
<p>It is possible for the root to pass transient references of internal objects to
external ones, with the condition that the external objects do not hold the
reference after the operation is finished.  One simple way to do that is to pass
copies of the Value Objects to external objects. It does not really matter what
happens to those objects, because it won't affect the integrity of the aggregate
in any way. </p>
<p>If objects of an Aggregate are stored in a database, only the root
should be obtainable through queries. The other objects should be obtained
through traversal associations.</p>
<p>Objects inside an Aggregate should be allowed to hold references to roots of
other Aggregates.</p>
<p>The root Entity has global identity, and is responsible for maintaining the 
invariants. Internal Entities have local identity.</p>
<p>Cluster the Entities and Value Objects into Aggregates and define boundaries
around each.  Choose one Entity to be the root of each Aggregate, and control
all access to the objects inside the boundary through the root. Allow external
objects to hold references to the root only. Transient references to internal
members can be passed out for use within a single operation only. Because the
root controls access, it cannot be blindsided by changes to the internals. This
arrangement makes it practical to enforce all invariants for objects in the
Aggregate and for the Aggregate as a whole in any state change.</p>
<h2 id="factories"><a class="header" href="#factories">Factories</a></h2>
<p>Entities and Aggregates can often be large and complex – too complex to create in the constructor of the root entity. Infact trying to construct a complex aggregate in its constructure is in contradiction with what often happens in the domain itself.</p>
<p>When the object construction is a laborious process, creating the object involves a lot of knowledge about the internal structure of the object, about the relationships between the objects contained, and the rules applied to them. This means that each client of the object will hold specific knowledge about the object built. This breaks encapsulation of the domain objects and of the Aggregates. If the client belongs to the application layer, a part of the domain layer has been moved outside, messing up the entire design. In real life, it is like we are given plasti</p>
<p>Factories are used to encapsulate the knowledge necessary for object creation, and they are especially useful to create Aggregates. When the root of the Aggregate is created, all the objects contained by the Aggregate are created along with it, and all the invariants are enforced.</p>
<p>It is important for the creation process to be atomic. If it is not, there is a chance for the creation process to be half done for some objects, leaving them in an undefined state.</p>
<p>When the root is created, it is necessary that all objects subject to invariants are created too.</p>
<p>For immutable Value Objects it means that all attributes are initialized to their valid state. If an object cannot be created properly, an exception should be raised.</p>
<p>Therefore, shift the responsibility for creating instances of complex objects and Aggregates to a separate object, which may itself have no responsibility in the domain model but is still part of the domain design. Provide an interface that encapsulates all complex assembly and that does not require the client to reference the concrete classes of the objects being instantiated. Create entire Aggregates as a unit, enforcing their invariants.</p>
<p>A Factory Method is an object method which contains and hides knowledge necessary to create another object. This is very useful when a client wants to create an object which belongs to an Aggregate. The solution is to add a method to the Aggregate root, which takes care of the object creation, enforces all invariants, and returns a reference to that object, or to a copy of it.</p>
<p><img src="tech/notes/software-arch/../img/2021-12-03-09-36-07.png" alt="Factories-1" /></p>
<p>There are times when the construction of an object is more complex, or when the creation of an object involves the creation of a series of objects. For example: the creation of an Aggregate. Hiding the internal construction needs of an Aggregate can be done in a separate Factory object which is dedicated to this task. Let’s consider the example of a program module which</p>
<p><img src="tech/notes/software-arch/../img/2021-12-03-09-39-42.png" alt="" /></p>
<p>The Route ID generator is used to create a unique identity for each route which is necessary for an Entity.</p>
<p>When creating a Factory, we are forced to violate an object’s encapsulation. Whenever something changes in the object that has an impact on construction rules or on some of the invariants, we need to make sure the Factory is updated to support the new condition. Factories are tightly related to the objects they are created.</p>
<p>There has to be some logic which puts together an Aggregate. The logic does not naturally belong to any of the objects, because it is about the construction of other objects. It seems appropriate to use a special Factory class</p>
<p>There are times when a Factory is not needed, and a simple constructor is enough. Use a constructor when:</p>
<ul>
<li>The construction is not complicated.</li>
<li>The creation of an object does not involve the creation of others, and all the attributes needed are passed via the constructor.</li>
<li>The client is interested in the implementation, perhaps wants to choose the Strategy used.</li>
<li>The class is the type. There is no hierarchy involved, so no need to choose between a list of concrete implementations.</li>
</ul>
<p>Another observation is that Factories need to create new objects from scratch, or they are required to reconstitute objects which previously existed, but have been probably persisted to a database. Bringing Entities back into memory from their resting place in a database involves a completely different process than creating a new one. One obvious difference is that the new object does not need a new identity</p>
<h2 id="repositories"><a class="header" href="#repositories">Repositories</a></h2>
<p>The purpose of a Repository is to encapsulate all the logic needed to obtain object references. The domain objects won’t have to deal with the infrastructure to get the needed references to other objects of the domain.  They will just get them from the Repository and the model is regaining its clarity and focus. </p>
<p>The Repository may store references to some of the objects. When an object is created, it may be saved in the Repository, and retrieved from there to be used later.  If the client requested an object from the Repository, and the Repository does not have it, it may get it from the storage. Either way, the Repository acts as a storage place for globally accessible objects. </p>
<p>The Repository may also include a Strategy. It may access one persistence storage or another based on the specified Strategy. It may use different storage locations for different type of objects. The overall effect is that the domain model is decoupled from the need of storing objects or their references, and accessing</p>
<p>Provide Repositories only for aggregate roots the that actually need direct access.</p>
<p>A Repository may contain detailed information used to access the infrastructure, but its interface should be simple. A Repository should have a set of methods used to retrieve objects. The client calls such a method and passes one or more</p>
<p>There is a relationship between Factory and Repository. They are both patterns of the model-driven design, and they both help us to manage the life cycle of domain objects. While the Factory is concerned with the creation of objects, the Repository takes care of already existing objects. The Repository may cache objects locally, but most often it needs to retrieve them from a persistent storage. Objects are either created using a constructor or they are passed to a Factory to be constructed. For this reason, the Repository may be seen as a Factory, because it creates  objects. It is not a creation from scratch, but a reconstitution of an object which existed. We should not mix a Repository with a Factory. The Factory should create new objects, while the Repository should find already created objects. When a new object is to be added to the Repository, it should be created first using the Factory, and then it should be given to the Repository which will store it like in the example below.</p>
<p>Another way this is noted is that Factories are &quot;pure domain&quot;, but that Repositories can contain links to the infrastructure, eg. the database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture-2"><a class="header" href="#software-architecture-2">Software Architecture</a></h1>
<p>A random recopilation of Software Architecture principles and ideas I've found
online.</p>
<h2 id="conwayss-law"><a class="header" href="#conwayss-law">Conways's Law</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Conway%27s_law">read more..</a></p>
<pre><code>Any organization that designs a system (defined broadly) will produce
a design whose structure is a copy of the organization's 
communication structure.
— Melvin E. Conway
</code></pre>
<p>The law is based on the reasoning that in order for a software module to function, multiple authors must communicate frequently with each other. Therefore, the software interface structure of a system will reflect the social boundaries of the organizations that produced it, across which communication is more difficult. Conway's law was intended as a valid sociological observation, although sometimes it's used in a humorous context.
other. Therefore, the software interface structure of a system will 
reflect the social boundaries of the organizations that produced it, 
across which communication is more difficult. Conway's law was intended 
as a valid sociological observation, although sometimes it's used in a 
humorous context.</p>
<h2 id="hyrums-law"><a class="header" href="#hyrums-law">Hyrum's Law</a></h2>
<p><a href="https://www.hyrumslaw.com/#">read more..</a></p>
<p>Hyrum's law states the following:</p>
<pre><code>With a sufficient number of users of an API,
it does not matter what you promise in the contract:
all observable behaviors of your system
will be depended on by somebody.
</code></pre>
<p>It talks about how &quot;implicit interfaces&quot;, not in the sense implicit implemented
interfaces, like in Go, but rather dependency contracts that are implicitly
estrablished on large scale systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-compilation-of-concepts-before-choosing-your-linux-distribution"><a class="header" href="#a-basic-compilation-of-concepts-before-choosing-your-linux-distribution">A basic compilation of concepts before choosing your Linux distribution</a></h1>
<p>This post is a compilation of Wikipedia, ArchWiki and Stackoverflow posts. I took a small but tasty bite of each post in order to gather a base knowledge in order to start your research for the Linux distribution that best suits you. Beware you might found your self researching a bit of history you might forget, reading specific  documentation of software you might not use and maybe running some tests on your local machine in order to fully understand all of these concepts.</p>
<h2 id="x"><a class="header" href="#x">X</a></h2>
<p>The <strong>X Window System</strong> (<strong>X11</strong>, or simply <strong>X</strong>) is a <a href="https://en.wikipedia.org/wiki/Windowing_system">windowing system</a> for <a href="https://en.wikipedia.org/wiki/Bitmap">bitmap</a> displays (aka. &quot;the pix-map&quot;, which refers to a map of pixels), common on <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> <a href="https://en.wikipedia.org/wiki/Operating_systems">operating systems</a>. X provides the basic <a href="https://en.wikipedia.org/wiki/Software_framework">framework</a> for a <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> environment: drawing and moving <a href="https://en.wikipedia.org/wiki/Window_(computing)">windows</a> on the <a href="https://en.wikipedia.org/wiki/Display_device">display device</a> and interacting with a <a href="https://en.wikipedia.org/wiki/Computer_mouse">mouse</a> and <a href="https://en.wikipedia.org/wiki/Computer_keyboard">keyboard</a>. X does not mandate the user interface – this is handled by individual programs. As such, the visual styling of X-based environments varies greatly; different programs may present radically different interfaces.</p>
<p>The <a href="https://en.wikipedia.org/wiki/X_protocol">X protocol</a> (clearly the protocol that X Window System implements) has been at version 11 (hence &quot;X11&quot;) since September 1987. The <a href="https://en.wikipedia.org/wiki/X.Org_Foundation">X.Org Foundation</a> leads the X project, with the current reference implementation, <a href="https://en.wikipedia.org/wiki/X.Org_Server">X.Org Server</a>, available as <a href="https://en.wikipedia.org/wiki/Free_and_open_source_software">free and open source software</a> under the <a href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a> and similar <a href="https://en.wikipedia.org/wiki/Permissive_free_software_licences">permissive licenses</a>.</p>
<p>The X Window System is based on a <a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client–server model</a>: a single <a href="https://en.wikipedia.org/wiki/Server_(computing)">server</a> controls the <a href="https://en.wikipedia.org/wiki/Input/output">input/output</a> hardware, such as the <a href="https://en.wikipedia.org/wiki/Computer_screen">screen</a>, the <a href="https://en.wikipedia.org/wiki/Computer_keyboard">keyboard</a>, and the <a href="https://en.wikipedia.org/wiki/Computer_mouse">mouse</a>; all application <a href="https://en.wikipedia.org/wiki/Computer_program">programs</a> act as <a href="https://en.wikipedia.org/wiki/Client_(computing)">clients</a>, interacting with the <a href="https://en.wikipedia.org/wiki/User_(computing)">user</a> and with the other clients via the server.</p>
<p><strong>Xorg</strong></p>
<p>Xorg (commonly referred as simply <strong>X</strong>) is the most popular display server among Linux users. Its ubiquity has led to making it an ever-present requisite for GUI applications, resulting in massive adoption from most distributions. See the <a href="https://en.wikipedia.org/wiki/X.Org_Server">Xorg</a> Wikipedia article or visit the <a href="https://www.x.org/wiki/">Xorg website</a> for more details.</p>
<p>In other words, <strong>X</strong> is an <strong>application</strong> that manages one or more graphics displays and one or more input devices (keyboard, mouse, etc.) connected to the computer.</p>
<p><strong>It works as a server</strong> and can run on the local computer or on another computer on the network. Services can communicate with the X server to display graphical interfaces and receive input from the user.</p>
<p>It's worth noting, a common component used with an X server is the Window Manager, an application that manages the resizing and moving of windows and decorative elements of windows such as title bars, minimize, and close buttons.</p>
<p>The X server can be started with the <code>startx</code> command, or more commonly, from a <strong>display manager</strong> such as gdm, lightdm etc...</p>
<p><code>~/.xinitrc</code> is a shell script used by xinit, that starts the X server when not using a display manager, to define some application to start automatically in the X server.</p>
<p><code>/etc/X11/xorg.conf</code> is a configuration file used to give the X server information about the hardware components used, but now the X server can avoid using it, because it is capable of autoconfiguring itself.</p>
<p><strong>X is a server</strong> (meaning a program which other programs call upon and be called by) which is responsible for creating a graphical environment and if it fails for whatever reason, you'll be greeted by Command Line Interface (CLI).</p>
<p>The term <strong>server</strong> can also be said to apply to PulseAudio, which is the sound server, and it calls applications and is called upon to produce sound.</p>
<h2 id="sound-server"><a class="header" href="#sound-server">Sound Server</a></h2>
<p>In a <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> operating system, a sound server mixes different data streams and sends out a single unified audio to an output device. The mixing is usually done by software, or by hardware if there is a supported <a href="https://en.wikipedia.org/wiki/Sound_card">sound card</a>.</p>
<p><strong>Layer</strong></p>
<p>The &quot;sound stack&quot; can be visualized as follows, with programs in the upper layers calling elements in the lower layers:</p>
<ul>
<li>
<p>Applications (e.g. mp3 player, web video)</p>
</li>
<li>
<p>Sound server (e.g. aRts, ESD, <a href="https://en.wikipedia.org/wiki/JACK_Audio_Connection_Kit">JACK</a>, <a href="https://en.wikipedia.org/wiki/PulseAudio">PulseAudio</a>)</p>
</li>
<li>
<p>Sound subsystem (described as kernel modules or drivers; e.g. <a href="https://en.wikipedia.org/wiki/Open_Sound_System">OSS</a>, <a href="https://en.wikipedia.org/wiki/Advanced_Linux_Sound_Architecture">ALSA</a>)</p>
</li>
<li>
<p>Operating system kernel (e.g. <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="https://en.wikipedia.org/wiki/Unix">Unix</a>)</p>
</li>
</ul>
<h2 id="gui-toolkits"><a class="header" href="#gui-toolkits">GUI Toolkits</a></h2>
<p><strong>What is KDE, GTK, GTK+, QT, and/or GNOME?</strong></p>
<p><strong>GTK</strong>, <strong>GTK+</strong>, and <strong>Qt</strong> are <strong>GUI toolkits</strong>. These are libraries that developers use to design graphical interfaces, all running on top of the X Server. These are things that you need to install as dependencies. They're the Linux &quot;equivalent&quot; to Windows' <strong>GDI/GDI+</strong>. When an application uses any of these, it will always have a general &quot;look and feel&quot;.</p>
<p><strong>GNOME</strong> and <strong>KDE</strong> are <strong>Desktop Environment</strong>s. <strong>GNOME</strong> primarily uses the <strong>GTK+</strong> toolkit, while <strong>KDE</strong> primarily uses the <strong>Qt</strong> toolkit. <em>There are applications designed for GNOME or KDE, such as a settings menu or a default music player, usually in the appropriate toolkit</em>. These Desktop Environments have a set of utilities/window managers/design specification to create a more unified desktop. You can mix the two if you feel like it, but you may run into issues with colliding standards and applications (which you might occasionally run into on systems like Arch).</p>
<p>Unity, another desktop environment, uses many of the GNOME utilities (Nautilus, Rhythmbox, etc.), so Unity is more GNOME than KDE.</p>
<p><em>Source: https://askubuntu.com/questions/249150/what-is-kde-gtk-gtk-qt-and-or-gnome</em></p>
<p><em>For more information: https://wiki.archlinux.org/index.php/Uniform_look_for_Qt_and_GTK_applications</em></p>
<h2 id="desktop-environments"><a class="header" href="#desktop-environments">Desktop Environments</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/Desktop_environment">desktop environment</a> (<strong>DE</strong>) is an implementation of the <a href="https://en.wikipedia.org/wiki/Desktop_metaphor">desktop metaphor</a> made of a bundle of programs, which share a common graphical user interface (GUI).</p>
<p>A desktop environment bundles together a variety of components to provide common graphical user interface elements such as icons, toolbars, wallpapers, and desktop widgets. Additionally, most desktop environments include a set of integrated applications and utilities. Most importantly, desktop environments provide their own <a href="https://wiki.archlinux.org/index.php/Window_manager">window manager</a>, which can however usually be replaced with another compatible one.</p>
<p>The user is free to configure their GUI environment in any number of ways. Desktop environments simply provide a complete and convenient means of accomplishing this task. Note that users are free to mix-and-match applications from multiple desktop environments. For example, a <a href="https://wiki.archlinux.org/index.php/KDE">KDE</a> user may install and run <a href="https://wiki.archlinux.org/index.php/GNOME">GNOME</a> applications such as the <a href="https://wiki.archlinux.org/index.php/Epiphany">Epiphany</a> web browser, should he/she prefer it over KDE's Konqueror web browser. One drawback of this approach is that many applications provided by desktop environment projects rely heavily upon their DE's respective underlying libraries. As a result, installing applications from a range of desktop environments will require installation of a larger number of dependencies. Users seeking to conserve disk space often avoid such mixed environments, or chose alternatives which do depend on only few external libraries.</p>
<p>Furthermore, DE-provided applications tend to integrate better with their native environments. Superficially, mixing environments with different widget toolkits will result in visual discrepancies (that is, interfaces will use different icons and widget styles). In terms of usability, mixed environments may not behave similarly (e.g. single-clicking versus double-clicking icons; drag-and-drop functionality) potentially causing confusion or unexpected behavior.</p>
<p>Prior to installing a desktop environment, a functional X server installation is required. See <a href="https://wiki.archlinux.org/index.php/Xorg">Xorg</a> for detailed information. Some desktop environments may also support <a href="https://wiki.archlinux.org/index.php/Wayland">Wayland</a> as an alternative to X, but most of these are still experimental.</p>
<h2 id="windows-manager"><a class="header" href="#windows-manager">Windows Manager</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/Window_manager">window manager</a> (WM) is system software that controls the placement and appearance of windows within a windowing system in a graphical user interface (GUI). It can be part of a <a href="https://wiki.archlinux.org/index.php/Desktop_environment">desktop environment</a> (DE) or be used standalone. Window managers are X clients that control the appearance and behavior of the frames (&quot;windows&quot;) where the various graphical applications are drawn. They determine the border, title bar, size, and ability to resize windows, and often provide other functionality such as reserved areas for sticking <a href="http://windowmaker.org/dockapps/">dockapps</a> like <a href="https://wiki.archlinux.org/index.php/Window_Maker">Window Maker</a>, or the ability to tab windows like <a href="https://wiki.archlinux.org/index.php/Fluxbox">Fluxbox</a>. Some window managers are even bundled with simple utilities like menus to start programs or to configure the WM itself.</p>
<p><strong>There are 3 types of window managers</strong></p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Window_manager#Stacking_window_managers">Stacking</a> (aka floating) window managers provide the traditional desktop metaphor used in commercial operating systems like Windows and OS X. Windows act like pieces of paper on a desk, and can be stacked on top of each other.</li>
<li><a href="https://wiki.archlinux.org/index.php/Window_manager#Tiling_window_managers">Tiling</a> window managers &quot;tile&quot; the windows so that none are overlapping. They usually make very extensive use of key-bindings and have less (or no) reliance on the mouse. Tiling window managers may be manual, offer predefined layouts, or both. </li>
<li><a href="https://wiki.archlinux.org/index.php/Window_manager#Dynamic_window_managers">Dynamic</a> window managers can dynamically switch between tiling or floating window layout.</li>
</ul>
<p>Source: https://wiki.archlinux.org/index.php/Window_manager</p>
<h2 id="display-manager"><a class="header" href="#display-manager">Display Manager</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/X_display_manager_(program_type)">display manager</a>, or login manager, is typically a graphical user interface that is displayed at the end of the boot process in place of the default shell. There are various implementations of display managers, just as there are various types of <a href="https://wiki.archlinux.org/index.php/Window_managers">window managers</a> and <a href="https://wiki.archlinux.org/index.php/Desktop_environments">desktop environments</a>. There is usually a certain amount of customization and theme-ability available with each one. Some display manager are LightDM, Gdm, Greetd and XDM</p>
<h2 id="init-systems"><a class="header" href="#init-systems">Init Systems</a></h2>
<p>In <a href="https://en.wikipedia.org/wiki/Unix">Unix</a>-based computer <a href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a>, <strong>init</strong> (short for <em>initialization</em>) is the first <a href="https://en.wikipedia.org/wiki/Process_(computer_science)">process</a> started during <a href="https://en.wikipedia.org/wiki/Booting">booting</a> of the computer system. Init is a <a href="https://en.wikipedia.org/wiki/Daemon_(computing)">daemon</a> process that continues running until the system is shut down. It is the direct or indirect <a href="https://en.wikipedia.org/wiki/Parent_process">ancestor</a> of all other processes and automatically adopts all <a href="https://en.wikipedia.org/wiki/Orphan_process">orphaned processes</a>. Init is started by the <a href="https://en.wikipedia.org/wiki/Kernel_(computing)">kernel</a> during the <a href="https://en.wikipedia.org/wiki/Booting">booting</a> process; a <a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a> will occur if the kernel is unable to start it. </p>
<p>The init <em>scripts</em> (or <em>rc</em>) are launched by the init process to guarantee basic functionality on system start and shutdown. This includes (un)mounting of <a href="https://wiki.archlinux.org/index.php/File_system">file systems</a> and launching of <a href="https://wiki.archlinux.org/index.php/Daemons">daemons</a>. A <em>service manager</em> takes this one step further by providing active control over launched processes, or <a href="https://en.wikipedia.org/wiki/Process_Supervision">process supervision</a>. An example is to monitor for crashes and restart processes accordingly.</p>
<p>Several additional init implementations have been created, attempting to address design limitations in the traditional versions. These include <a href="https://en.wikipedia.org/wiki/Launchd">launchd</a>, the <a href="https://en.wikipedia.org/wiki/Service_Management_Facility">Service Management Facility</a>, <a href="https://en.wikipedia.org/wiki/Systemd">systemd</a> and <a href="https://en.wikipedia.org/wiki/OpenRC">OpenRC</a>.</p>
<p>Various efforts have been made to replace the traditional init daemons to address this and other design problems, including:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/GoboLinux#Boot_system">BootScripts</a> in <a href="https://en.wikipedia.org/wiki/GoboLinux">GoboLinux</a></li>
<li><a href="https://en.wikipedia.org/wiki/Busybox">busybox-init</a>, suited to <a href="https://en.wikipedia.org/wiki/Embedded_operating_system">embedded operating systems</a>, employed by <a href="https://en.wikipedia.org/wiki/OpenWrt">OpenWrt</a> before it was replaced with <a href="https://en.wikipedia.org/wiki/OpenWrt#procd">procd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Daemon_(computing)">Daemons</a>, by a modification of the init start process by <a href="https://en.wikipedia.org/w/index.php?title=KahelOS&amp;action=edit&amp;redlink=1">KahelOS</a>, daemons are started only when the DE (desktop environment) started</li>
<li>eINIT, a full replacement of init designed to start processes <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)">asynchronously</a>, but with the potential of doing it without <a href="https://en.wikipedia.org/wiki/Shell_scripts">shell scripts</a></li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Epoch_(init_system)&amp;action=edit&amp;redlink=1">Epoch</a>, a single-threaded Linux init system focused on simplicity and service management[<a href="https://en.wikipedia.org/wiki/Init#cite_note-14">14]</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initng">Initng</a>, a full replacement of init designed to start processes asynchronously</li>
<li><a href="https://en.wikipedia.org/wiki/Launchd">launchd</a>, a replacement for init in <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a>/<a href="https://en.wikipedia.org/wiki/MacOS">macOS</a>/<a href="https://en.wikipedia.org/wiki/IOS">iOS</a>/<a href="https://en.wikipedia.org/wiki/TvOS">tvOS</a> starting with <a href="https://en.wikipedia.org/wiki/Mac_OS_X_v10.4">Mac OS X v10.4</a> (it launches SystemStarter to run old-style 'rc.local' and SystemStarter processes)</li>
<li><a href="https://web.archive.org/web/20071211041543/http://www.pardus.org.tr/eng/projeler/comar/SpeedingUpLinuxWithPardus.html">Mudur</a>, an init replacement written in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> and designed to start process asynchronously in use by the <a href="https://en.wikipedia.org/wiki/Pardus_(operating_system)">Pardus</a> Linux distribution</li>
<li><a href="https://lede-project.org/docs/guide-developer/procd">procd</a> is used in LEDE/OpenWRT</li>
<li><a href="https://web.archive.org/web/20070824084840/http://www-128.ibm.com/developerworks/linux/library/l-boot.html">some unnamed proofs-of concept</a> based on <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> (since makefiles can easily express dependencies and be launched in parallel)</li>
<li>nosh, a suite of system-level utilities for initializing and running a BSD or Linux system, for managing daemons, terminals and logging</li>
<li><a href="https://en.wikipedia.org/wiki/OpenRC">OpenRC</a>, a process spawner that utilizes system-provided init, while providing process isolation, parallelized startup, and service dependency; used by <a href="https://en.wikipedia.org/wiki/Gentoo_Linux">Gentoo</a> and its derivatives and available as an option in <a href="https://en.wikipedia.org/wiki/Devuan">Devuan</a></li>
<li><a href="https://en.wikipedia.org/wiki/Runit">runit</a>, a <a href="https://en.wikipedia.org/wiki/Cross-platform">cross-platform</a> full replacement for init with parallel starting of services, used by default in <a href="https://en.wikipedia.org/wiki/Void_Linux">Void Linux</a> and Artix Linux.</li>
<li>s6, another cross-platform full replacement for init, similar to runit, based on clear principled architecture design choices.</li>
<li>Sun <a href="https://en.wikipedia.org/wiki/Service_Management_Facility">Service Management Facility</a> (SMF), a complete replacement/redesign of init from the ground up in <a href="https://en.wikipedia.org/wiki/Illumos">illumos</a>/<a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris</a> starting with Solaris 10, but launched as the only service by the original System V-style init</li>
<li><a href="https://en.wikipedia.org/wiki/Guix_System_Distribution#GNU_Shepherd">Shepherd</a>, the <a href="https://en.wikipedia.org/wiki/GNU">GNU</a> service and daemon manager which provides asynchronous, dependency-based initialisation; written in <a href="https://en.wikipedia.org/wiki/Guile_(programming_language)">Guile Scheme</a> and meant to be interactively hackable during normal system operation</li>
<li><a href="https://en.wikipedia.org/wiki/Systemd">systemd</a>, a software suite, full replacement for init in Linux that includes an init daemon, with concurrent starting of services, service manager, and other features.</li>
<li><a href="https://en.wikipedia.org/wiki/SystemStarter">SystemStarter</a>, a process spawner started by the BSD-style init in <a href="https://en.wikipedia.org/wiki/Mac_OS_X">Mac OS X</a> prior to Mac OS X v10.4</li>
<li><a href="https://en.wikipedia.org/wiki/Upstart_(software)">Upstart</a>, a full replacement of init designed to start processes asynchronously. Initiated by <a href="https://en.wikipedia.org/wiki/Ubuntu_(operating_system)">Ubuntu</a> and used by them until 2014. It was also used in Fedora 9, Red Hat Enterprise Linux 6 and <a href="https://en.wikipedia.org/wiki/Google">Google</a>'s <a href="https://en.wikipedia.org/wiki/Chrome_OS">Chrome OS</a>.</li>
</ul>
<p>As of February 2019, systemd has been <a href="https://en.wikipedia.org/wiki/Systemd#Adoption_and_reception">adopted</a> by most major Linux distributions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-check-for-linux-performance"><a class="header" href="#basic-check-for-linux-performance">Basic check for linux performance</a></h1>
<p>This video is taken from <a href="https://www.brendangregg.com/blog/2015-12-03/linux-perf-60s-video.html">this blog post</a>.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZdVpKx6Wmc8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>In short:</p>
<pre><code class="language-bash">uptime \
dmesg | tail \
vmstat 1 \
mpstat -P ALL 1 \
pidstat 1 \
iostat -xz 1 \
free -m \
sar -n DEV 1 \
sar -n TCP,ETCP 1 \
top
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssh"><a class="header" href="#ssh">ssh</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemd"><a class="header" href="#systemd">Systemd</a></h1>
<p>Systemd is a system and service manager for Linux operating systems. When run as first process on boot (as PID 1), it acts as init system that brings up and maintains userspace services. Separate instances are started for logged-in users to start their services.
Systemd is usually not invoked directly by the user, but is installed as the /sbin/init symlink and started during early boot. The user manager instances are started automatically through the user@.service(5) service.</p>
<h2 id="before-systemd-sysv-init"><a class="header" href="#before-systemd-sysv-init">Before systemd (SysV init)</a></h2>
<p>Before systemd, the init system used previously in Linux was called SysVinit. A script used to manage a service in SysVinit was known as a SysV init script, which were &quot;<em>imperative</em>&quot;. Backwards compatibility for legacy scripts remains 99.9% intact with systemd.</p>
<p><a href="http://www.styma.org/SunAtHome/sample_files/sshd.html">Example for the sshd SysV init script</a></p>
<p>Nowadays the Systemd unit files are &quot;<em>declaratives</em>&quot; and systemd simply
interprets them and hanldes the initialization of the service. For example the sshd.service unit file</p>
<p>Just <code>cat $(pkg-config systemd --variable=systemdsystemunitdir)/sshd.service</code> :</p>
<pre><code class="language-toml">[Unit]
Description=OpenSSH Daemon
Wants=sshdgenkeys.service
After=sshdgenkeys.service
After=network.target

[Service]
ExecStart=/usr/bin/sshd -D
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=always

[Install]
WantedBy=multi-user.target
</code></pre>
<h1 id="unit-files"><a class="header" href="#unit-files">Unit files</a></h1>
<p>The unit files on your system determine how systemd will start and run. Each corresponds to a single activity or component — or unit in systemd terms. Each unit file is a simple text file describing a unit, what it does, what needs to run before or afterward, and other details.</p>
<p>To see a list of all the unit files installed in the system.</p>
<pre><code class="language-shell">systemctl list-unit-files
</code></pre>
<h2 id="system-unit-directories"><a class="header" href="#system-unit-directories">System unit directories</a></h2>
<p>(from the man page)</p>
<p>The systemd system manager reads unit configuration from various directories. Packages that want to install unit files shall place them in the directory returned by <code>pkg-config systemd --variable=systemdsystemunitdir</code>. Other directories checked are <code>/usr/local/lib/systemd/system</code> and <code>/usr/lib/systemd/system</code>.
User always take precedence. <code>pkg-config systemd --variable=systemdsystemconfdir</code> returns the path of the system configuration directory</p>
<p>Packages should alter the content of these directories only with the enable and disable commands of the systemctl(1) tool</p>
<h2 id="user-unit-directories"><a class="header" href="#user-unit-directories">User unit directories</a></h2>
<p>Applications should place their unit files in the directory returned by <code>pkg-config systemd --variable=systemduserunitdir</code>. Global configuration is done in the directory reported by <code>pkg-config systemd --variable=systemduserconfdir</code>. The enable and disable commands of the systemctl(1) tool can handle both global (i.e. for all users) and private (for one user) enabling/disabling of units.</p>
<h1 id="unit-types"><a class="header" href="#unit-types">Unit types</a></h1>
<p>There are numerous types of units systemd understands. The two most common for system owners to deal with are service units and target units. To list unit files on your system of each of these types, use the systemctl command:</p>
<pre><code class="language-shell">systemctl list-unit-files --type service
systemctl list-unit-files --type target
</code></pre>
<h2 id="service-units"><a class="header" href="#service-units">Service units</a></h2>
<pre><code class="language-shell">man systemd.service
</code></pre>
<p>One interesting feature of systemd is that it monitors processes it <strong>starts with service units</strong>.</p>
<p>For example: <code>/usr/lib/systemd/system/sshd.service</code></p>
<pre><code class="language-shell">sudo systemctl [command] NAME.service
</code></pre>
<p>Typical commands include:</p>
<ul>
<li><strong>start</strong>: starts a systemd unit</li>
<li><strong>stop</strong>: attempts to “nicely” end a service</li>
<li><strong>status</strong>: provides detailed information on a service</li>
<li><strong>restart</strong>: restarts (stops and then starts) the specified service</li>
<li><strong>enable</strong>: hooks (links) a unit to various places, for instance to run at boot</li>
<li><strong>disable</strong>: unhooks (unlinks) a unit, so it is not activated</li>
<li><strong>kill</strong>: when a service refuse to cooperate :eyes:</li>
<li><strong>is-enabled</strong>: checks if a service is enabled</li>
</ul>
<h2 id="target-units"><a class="header" href="#target-units">Target units</a></h2>
<p>Target units are used to link and group other units together to describe a desired system state. Some of these units may be services. Others may be additional target units with their own groups of units.</p>
<pre><code class="language-shell">man systemd.target
</code></pre>
<p>Example 1. Simple standalone target</p>
<pre><code class="language-toml"># emergency-net.target
[Unit]
Description=Emergency Mode with Networking
Requires=emergency.target systemd-networkd.service
After=emergency.target systemd-networkd.service
AllowIsolate=yes
</code></pre>
<h4 id="source"><a class="header" href="#source">Source</a></h4>
<ul>
<li>These series of blog posts: https://fedoramagazine.org/what-is-an-init-system/</li>
<li>Systemd man pages: https://man7.org/linux/man-pages/man1/systemd.1.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemds-journal"><a class="header" href="#systemds-journal">Systemd's Journal</a></h1>
<p>Before systemd-journald was <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a></p>
<p><strong>systemd-journald</strong> is a system service that collects and stores logging data. It creates and maintains structured, indexed journals based on logging information that is received from a variety of sources:</p>
<ul>
<li>Kernel log messages, via kmsg</li>
<li>Simple system log messages, via the libc syslog(3) call</li>
<li>Structured system log messages via the native Journal API, see sd_journal_print(3)</li>
<li>Standard output and standard error of service units. For further details see below.</li>
<li>Audit records, originating from the kernel audit subsystem</li>
</ul>
<p>The daemon will implicitly collect numerous metadata fields for each log messages in a secure and unfakeable way</p>
<h2 id="data-store"><a class="header" href="#data-store">Data Store</a></h2>
<p>The journal service stores log data either persistently below <strong>/var/log/journal</strong> or in a volatile way below <strong>/run/log/journal/</strong> (in the latter case it is lost at reboot).
By default, log data is stored persistently if /var/log/journal/ exists during boot, with an implicit fallback to volatile storage otherwise
Use <code>Storage=</code> in <code>/etc/systemd/journald.conf</code> (see <code>man journald.conf</code>) to configure where log data is placed, independently of the existence of /var/log/journal/</p>
<p>Logs are store in the following files: </p>
<ul>
<li><code>/run/log/journal/machine-id/*.journal</code></li>
<li><code>/run/log/journal/machine-id/*.journal~</code></li>
<li><code>/var/log/journal/machine-id/*.journal</code></li>
<li><code>/var/log/journal/machine-id/*.journal~</code></li>
</ul>
<p><strong>Note:</strong> If the daemon is stopped uncleanly, or if the files are found to be corrupted, they are renamed using the <strong>&quot;.journal~&quot;</strong></p>
<h2 id="journalctl"><a class="header" href="#journalctl">journalctl</a></h2>
<p><code>journalctl</code> is the command line tool to query the systemd journal (<code>man journalctl</code>)</p>
<p>If called without parameters, it will show the full contents of the journal, starting with the oldest entry collected</p>
<h2 id="some-my-most-used-journal-commands"><a class="header" href="#some-my-most-used-journal-commands">Some my most used journal commands:</a></h2>
<pre><code class="language-bash">journalctl -e # to start from last to old
# or
journalctl -r # to reverse it
# or
journalctl -o &lt;output-mode&gt;
# Output modes: short, short-precise, short-iso, short-iso-precise, short-full, short-monotonic, short-unix, verbose, export, json, json-pretty, json-sse, json-seq, cat, with-unit
journalctl -b &lt;boot-id|empty&gt; -u &lt;UnitName&gt; # If boot-id may be empty, in which case logs for the current boot will be shown.
# or
journalctl -p &lt;priority&gt; # priority: &quot;emerg&quot;, &quot;alert&quot;, &quot;crit&quot;, &quot;err&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="podman"><a class="header" href="#podman">Podman</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>The best way of getting started with Podman, for me, is its website:
<a href="http://podman.io">podman.io</a>.</p>
<p>It also has a handful of <a href="https://docs.podman.io/en/latest/Tutorials.html">tutorials</a> to get started much quicker if you don't really wanna get into the concepts.</p>
<h2 id="rootless-podman"><a class="header" href="#rootless-podman">Rootless podman</a></h2>
<p>These two videos are super useful to understand how podman runs users rootless
and how the different UID and GUID are mapped between <a href="tech/notes/linux/containers/">namespaces</a>.</p>
<h3 id="understanding-root-inside-and-outside-a-container"><a class="header" href="#understanding-root-inside-and-outside-a-container">Understanding Root Inside and Outside a Container</a></h3>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ZgXpWKgQclc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="how-user-namespaces-work-in-rootless-containers"><a class="header" href="#how-user-namespaces-work-in-rootless-containers">How User Namespaces Work in Rootless Containers</a></h3>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Ac2boGEz2ww" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Here's a list that categorize the known issues and irregularities when running
podman as rootless:</p>
<p><a href="https://github.com/containers/podman/blob/main/rootless.md">https://github.com/containers/podman/blob/main/rootless.md</a></p>
<h2 id="generate-unit-file-for-systemd"><a class="header" href="#generate-unit-file-for-systemd">Generate Unit file for systemd</a></h2>
<p>Once a container/pod is running you can generate an unit file for systemd with the following command:</p>
<pre><code class="language-bash">podman generate systemd &lt;pod/container-name&gt;  --name 
</code></pre>
<p>Note: </p>
<ul>
<li>Copying unit files to <code>/etc/systemd/system</code> and enabling it marks the unit file to be automatically started at boot. And similarly, copying a unit file to <code>$HOME/.config/systemd/user</code> and enabling it marks the unit file to be automatically started on user login.</li>
<li>As of Podman 4.0, if the pod was craeted with a <code>pod.yml</code> and <code>podman play kube</code> it's not possible to add the <code>--new</code> file to the systemd generated command </li>
</ul>
<pre><code>Error: cannot use --new on pod &quot;&lt;container-id&gt;&quot;: no create command found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-philosphy"><a class="header" href="#software-philosphy">Software Philosphy</a></h1>
<h2 id="regulating-software-practices"><a class="header" href="#regulating-software-practices">Regulating software practices</a></h2>
<p>Robert C. Martín</p>
<p>An interesting analogy with doctors done by Uncle Bob with software engineers coming up with ways of regulating themselves.</p>
<p>TODO: Find the video</p>
<h2 id="preventing-the-collapse-of-civilization"><a class="header" href="#preventing-the-collapse-of-civilization">Preventing the Collapse of Civilization</a></h2>
<p>An interesting take on the huge amount of abstraction with have to deal nowadays while using software.</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ZSRHeXYDLko" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="no-silver-bullet"><a class="header" href="#no-silver-bullet">No silver bullet</a></h2>
<p>Frederick P. Brooks</p>
<pre><code>There is no single development, in either technology or management technique, 
which by itself promises even one order of magnitude improvement within a decade 
in productivity, in reliability, in simplicity.
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">read more..</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<h2 id="tls-exaplained"><a class="header" href="#tls-exaplained">TLS exaplained</a></h2>
<p>Every byte of a TLS connection explained and reproduced: <a href="https://tls.ulfheim.net">https://tls.ulfheim.net</a></p>
<h2 id="server-cert-sign-by-custom-ca"><a class="header" href="#server-cert-sign-by-custom-ca">Server cert sign by custom CA</a></h2>
<p>The CA consist of a root (private) key (i.e <code>root-ca.key</code>) and a public <code>root-ca.crt</code>.</p>
<p>The following script generates a server side certificate in the and signs it with the CA.</p>
<pre><code class="language-bash">#!/bin/bash

# This scripts acts as a CA to issue a server-certificate.

# Generate a key for the particular services
openssl genrsa -out $1.key 2048 

# Generate que Sign request from the previouly generate key for a cusom common-name
openssl req -new -sha256 \
    -key $1.key \
    -subj &quot;/C=US/ST=CA/O=Sec26, Inc./CN=$1.common.name&quot; \
    -out $1.csr
#    -reqexts SAN \
#    -config &lt;(cat /etc/ssl/openssl.cnf \
#        &lt;(printf &quot;\n[SAN]\nsubjectAltName=DNS:$1.common.name&quot;)) \

# Genrate the actual server-certificate and sign it with the root-ca.key (private) (u also need the root-ca.crt (public)
# that will be present in the clients in order to trust the generated server-certificate).
openssl x509 -req -in $1.csr \
    -CA root-ca.crt -CAkey root-ca.key -CAcreateserial \
    -out $1.crt -days 500 -sha256
</code></pre>
<p>The output should be something like: <code>./test.sh &lt;name&gt;</code></p>
<pre><code class="language-text">Generating RSA private key, 2048 bit long modulus
...........+++
..........+++
e is 65537 (0x10001)
Signature ok
subject=/C=US/ST=CA/O=Sec26, Inc./CN=&lt;name&gt;.common.name
Getting CA Private Key
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="designing-abstractions"><a class="header" href="#designing-abstractions">Designing Abstractions</a></h2>
<ul>
<li>The most fundamental element of computer science:
<ul>
<li>NOT algorithm design! Computers are fast enough to eliminate algorithmic considerations from most programming tasks.</li>
<li>The most important problem is managing complexity:
<ul>
<li>Technology allows us to build systems much larger than we can understand.</li>
<li>Biggest impediment to building computer systems is our ability to understand them.</li>
<li>Software complexity increases over time, system becomes brittle (changes too expensive or too dangerous).</li>
</ul>
</li>
<li>Fundamental problem in computer science: decompose complex problems and systems into smaller units that can be understood in isolation.</li>
<li>I use the term &quot;abstraction&quot; to refer to these units.</li>
</ul>
</li>
<li>&quot;Sweet&quot; abstractions:
<ul>
<li>Minimum surface area for maximum volume: simple interface hides a lot of implementation complexity.</li>
<li>Easy to use:
<ul>
<li>Less code to type</li>
<li>Less to learn</li>
</ul>
</li>
<li>Easy to make changes: impact of changes will be isolated inside an abstraction.</li>
<li>Reusability:
<ul>
<li>Same abstraction can be reused for many different tasks.</li>
<li>Abstraction provides a framework that allows many other components to be incorporated or work together.</li>
</ul>
</li>
<li>Sometimes called &quot;information hiding&quot; or &quot;separation of concerns&quot;:
<ul>
<li>Hide design decisions, such as a complex algorithm or data structure, behind a simple interface.</li>
</ul>
</li>
</ul>
</li>
<li>How to find the sweet spot?
<ul>
<li>Facts precede concepts: examine a lot of code, look for common tasks.</li>
<li>Separate the common case:
<ul>
<li>Powerful interfaces eventually need a lot of features, but most of them aren't used very often.</li>
<li>Identify the common case: &quot;what's the simplest it can possibly be?&quot;</li>
<li>First make the common case as simple as possible, then find a way to support the special cases without complicating the common case:
<ul>
<li>Optional arguments</li>
<li>Additional methods to handle special cases</li>
</ul>
</li>
<li>Make it easy to learn the common case without having to learn about fancy features; pick up the optional features one at a time, as needed.</li>
</ul>
</li>
<li>Avoid classitis: more interfaces are not necessarily better!
<ul>
<li>Don't force people to use interfaces that aren't relevant for the common case.</li>
<li>Define the highest-level, most useful interfaces first; then fill in the intermediate interfaces if needed.</li>
</ul>
</li>
<li>Allow customization/extension, but don't require it!
<ul>
<li>Provide good defaults.</li>
</ul>
</li>
<li>Minimize error handling:
<ul>
<li>Define errors out of existence.</li>
<li>Centralized error handling: hide errors that can't normally be recovered from.</li>
</ul>
</li>
<li>Don't introduce restrictions just because you can't imagine a reasonable use case
<ul>
<li>Getting rid of restrictions simplifies the interface.</li>
</ul>
</li>
<li>Are there things that nearly everyone will want? If so, just build them in automatically; don't make people ask for them.</li>
</ul>
</li>
<li>Some additional thoughts:
<ul>
<li>A great abstraction will be used in ways you never anticipated; don't assume you can anticipate all of the uses.</li>
<li>Move suffering inside the abstraction.</li>
<li>Hard for really smart people to design sweet interfaces because things don't seem complicated to them.</li>
<li>Plan on revisions: the first attempt is rarely sweet.</li>
<li>Sweat the details: the difference between a great abstraction and a clumsy one is often dozens of things each of which seems trivial.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-paste"><a class="header" href="#copy-paste">Copy Paste</a></h1>
<p>Handy oneliner or block of code that, at some point of my career, found myself using a lot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloud-oneliners"><a class="header" href="#cloud-oneliners">Cloud &quot;Oneliners&quot;</a></h1>
<p>A bunch of cloud oneliners I usually find my self needing.</p>
<h2 id="amazon-web-services-aws"><a class="header" href="#amazon-web-services-aws">Amazon Web Services (AWS)</a></h2>
<h3 id="aws-export-variables"><a class="header" href="#aws-export-variables">AWS Export variables</a></h3>
<p>Oneliner to export variables inside a container or somewhere you need to test any sdk and you don't have de awscli installed</p>
<pre><code class="language-bash">env | grep AWS | awk '{print &quot;export &quot; $1}'
</code></pre>
<h3 id="check-how-many-gb-you-have-on-ec2-snapshots"><a class="header" href="#check-how-many-gb-you-have-on-ec2-snapshots">Check how many GB you have on EC2 Snapshots</a></h3>
<p>This one is not mine actually, I stole it from a guy at work.</p>
<pre><code class="language-bash">aws ec2 describe-snapshots --query 'Snapshots[].VolumeSize' --output text |
	tr [:space:] '\n' |
	awk '{sum += $1} END {print sum, &quot;GB&quot;}'
</code></pre>
<h3 id="get-a-list-of-r53-records"><a class="header" href="#get-a-list-of-r53-records">Get a list of R53 records</a></h3>
<pre><code class="language-bash">aws route53 list-hosted-zones |
    jq '.HostedZones[] | .Id' |
    awk -F&quot;/&quot; '{print $3}' |
    tr -d '&quot;' |
    xargs -I{} aws route53 list-resource-record-sets --hosted-zone-id {} --query &quot;ResourceRecordSets[?Type == 'A']&quot; |
    jq '.[] .Name' | tr -d '\&quot;' | sed 's/.$//'
</code></pre>
<h3 id="create-ssm-activations-with-tags"><a class="header" href="#create-ssm-activations-with-tags">Create SSM activations with Tags</a></h3>
<pre><code class="language-bash">aws ssm create-activation \
  --default-instance-name &quot;managed-instance-name&quot; \
  --registration-limit 1 \
  --tags '[{&quot;Key&quot;:&quot;KEYNAME&quot;,&quot;Value&quot;: &quot;Value&quot;}]' \
  --iam-role service-role/AmazonEC2RunCommandRoleForManagedInstances
</code></pre>
<h3 id="aws-export-just-some--properties-to"><a class="header" href="#aws-export-just-some--properties-to">AWS Export (just some) <Service> properties to <FORMAT></a></h3>
<p>Export VPC Flowlogs' FlowLogId,ResourceId... to JSON</p>
<pre><code class="language-bash">aws ec2 describe-flow-logs --query &quot;FlowLogs[].[FlowLogId,ResourceId,LogFormat]&quot; 
</code></pre>
<p>Export VPC's VpcId and State to CSV</p>
<pre><code class="language-bash">aws ec2 describe-vpcs | jq '.Vpcs[] | &quot;\(.VpcId), \(.State)&quot;'`
</code></pre>
<h3 id="aws-delete-all-ssm-activations"><a class="header" href="#aws-delete-all-ssm-activations">AWS Delete all SSM activations</a></h3>
<p>There's no current way to select a bunch of activation and swipe them all at once (You must have <code>jq</code> installed)</p>
<pre><code class="language-bash">aws ssm describe-activations | \
  jq '.ActivationList | map(.ActivationId) | .[]' | \
  awk '{print &quot;aws ssm delete-activation --activation-id &quot; $1}'
</code></pre>
<h3 id="aws-whoami"><a class="header" href="#aws-whoami">AWS Whoami</a></h3>
<pre><code class="language-bash">aws sts get-caller-identity
</code></pre>
<h3 id="aws-assume-role-from-cli"><a class="header" href="#aws-assume-role-from-cli">AWS Assume Role from CLI</a></h3>
<pre><code class="language-bash">aws sts assume-role \
  --role-arn arn:aws:iam::123456789:role/TestAssumeRole \
  --role-session-name pirulo-session
</code></pre>
<h3 id="aws-assume-role-from-cli-and-set-credentials"><a class="header" href="#aws-assume-role-from-cli-and-set-credentials">AWS Assume Role from CLI and set credentials</a></h3>
<p>Run the following command's output to sh.</p>
<pre><code class="language-bash">aws sts assume-role --role-arn &quot;&lt;ROLE_ARN&gt;&quot; --role-session-name PiruloeSssion &gt; \
  keys.json.tmp &amp;&amp; \
  cat keys.json.tmp | \
  jq '.Credentials.SecretAccessKey' | \
  awk '{print &quot;export AWS_SECRET_ACCESS_KEY=&quot; $1}' &amp;&amp; \
  cat keys.json.tmp | jq '.Credentials.AccessKeyId' | \
  awk '{print &quot;export AWS_ACCESS_KEY_ID=&quot; $1}' &amp;&amp; \
  cat keys.json.tmp | \
  jq '.Credentials.SessionToken' | \
  awk '{print &quot;export AWS_SESSION_TOKEN=&quot; $1}' ; \
  echo &quot;export AWS_SECURITY_TOKEN=&quot; ; \
  rm -f keys.json.tmp
</code></pre>
<h3 id="aws-assume-role-from-cli-and-set-credentials-easier"><a class="header" href="#aws-assume-role-from-cli-and-set-credentials-easier">AWS Assume Role from CLI and set credentials (easier)</a></h3>
<pre><code class="language-bash">  set +x  # do not print credentials
  export $(printf &quot;AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s&quot; \
        $(aws sts assume-role \
        --role-arn &lt;ROLE_ARN&gt; \
        --role-session-name &lt;SESSION_NAME&gt; \
        --query &quot;Credentials.[AccessKeyId,SecretAccessKey,SessionToken]&quot; \
        --output text))
</code></pre>
<hr />
<h2 id="google-cloud-platform-gcp"><a class="header" href="#google-cloud-platform-gcp">Google Cloud Platform (GCP)</a></h2>
<h3 id="gcloud-whoami"><a class="header" href="#gcloud-whoami">Gcloud Whoami</a></h3>
<pre><code class="language-bash">gcloud config list account --format &quot;value(core.account)&quot;
</code></pre>
<h3 id="gcloud-parse-output-with-jq"><a class="header" href="#gcloud-parse-output-with-jq">Gcloud parse output with <code>jq</code></a></h3>
<pre><code class="language-bash">gcloud compute instances list --project=project-name --format=json --filter=&quot;creationTimestamp&gt;2020-09-03&quot; | \
  jq '.[] | .&quot;instance_id&quot; = .id | {zone,instance_id,account_id:&quot;project-name&quot;,cloud_provider:&quot;GCP&quot;}'
</code></pre>
<hr />
<h2 id="azure"><a class="header" href="#azure">Azure</a></h2>
<h3 id="azure-vm-get-id-inside-the-vm"><a class="header" href="#azure-vm-get-id-inside-the-vm">Azure VM get ID (Inside the VM)</a></h3>
<pre><code class="language-bash">curl -H Metadata:true &quot;http://169.254.169.254/metadata/instance/compute/vmId?api-version=2017-08-01&amp;format=text&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-useful-commands"><a class="header" href="#shell-useful-commands">Shell useful commands</a></h1>
<h2 id="decompressing-a-file"><a class="header" href="#decompressing-a-file">Decompressing a file</a></h2>
<p>Script for decompressing different kind of files</p>
<pre><code class="language-shell">#!/bin/bash
if [ -f $1 ]; then
	case $1 in
	*.tar.bz2) tar xjf $1 ;;
	*.tar.gz) tar xzf $1 ;;
	*.bz2) bunzip2 $1 ;;
	*.rar) unrar x $1 ;;
	*.gz) gunzip $1 ;;
	*.tar) tar xf $1 ;;
	*.tar.xz) tar xf $1 ;;
	*.tbz2) tar xjf $1 ;;
	*.tgz) tar xzf $1 ;;
	*.zip) unzip $1 ;;
	*.Z) uncompress $1 ;;
	*.7z) 7z x $1 ;;
	*) echo &quot;'$1' cannot be extracted via ex()&quot; ;;
	esac
else
	echo &quot;'$1' is not a valid file&quot;
fi
</code></pre>
<p>Remove all python package under pip freeze</p>
<pre><code class="language-shell"> pip freeze | xargs -I {} pip uninstall -y {}
</code></pre>
<h2 id="get-certs-from-website"><a class="header" href="#get-certs-from-website">Get certs from website</a></h2>
<pre><code class="language-shell">openssl s_client -showcerts -verify 5 -connect contre.lucas:443 &lt; /dev/null | awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/{ if(/BEGIN CERTIFICATE/){a++}; out=&quot;cert&quot;a&quot;.pem&quot;; print &gt;out}'
</code></pre>
<h2 id="sed-on-directory"><a class="header" href="#sed-on-directory">Sed on directory</a></h2>
<pre><code class="language-shell">find ./ -type f -exec sed -i -e 's/apple/orange/g' {} \;
</code></pre>
<pre><code class="language-shell">grep -rl 'apples' /dir_to_search_under | xargs sed -i 's/apples/oranges/g'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arch"><a class="header" href="#arch">Arch</a></h1>
<p>I suggest using the <a href="https://wiki.archlinux.org/">Arch wiki</a> instead if you
don't know what the command is doing.</p>
<h3 id="rollback-a-package-to-a-cached-version"><a class="header" href="#rollback-a-package-to-a-cached-version">Rollback a package to a cached version</a></h3>
<pre><code class="language-bash">sudo pacman -U /var/cache/pacman/pkg/&lt;package-name&gt;.pkg.tar.zst
# sudo pacman -U /var/cache/pacman/pkg/moc-1:2.5.2-3-x86_64.pkg.tar.zst
</code></pre>
<h3 id="dependency-tree-viewer"><a class="header" href="#dependency-tree-viewer">Dependency tree viewer</a></h3>
<pre><code class="language-bash">pactree &lt;package-name&gt;
# pactree mocp
</code></pre>
<h3 id="unused-packages"><a class="header" href="#unused-packages">Unused packages</a></h3>
<pre><code class="language-bash"># List them
pacman -Qtdq
# Remove them
sudo pacman -R $(pacman -Qtdq)
</code></pre>
<h3 id="clear-pacman-cache"><a class="header" href="#clear-pacman-cache">Clear Pacman cache</a></h3>
<p>Cache is usually located under <code>/var/cache</code></p>
<pre><code># pacman's built-in option
sudo pacman -Sc
#To remove all cached versions of uninstalled packages, re-run paccache with u flag
sudo paccache -ruk0
# To keep only one most recent version
sudo paccache -rk 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers-1"><a class="header" href="#containers-1">Containers</a></h1>
<hr />
<h2 id="podman-1"><a class="header" href="#podman-1">Podman</a></h2>
<h3 id="run-command-on-the-same-namespace-as-your-containers"><a class="header" href="#run-command-on-the-same-namespace-as-your-containers">Run command on the same Namespace as your containers</a></h3>
<p>This command is usefull when you want to re-define permission on rootless podman containers or to debug permissions in general.</p>
<pre><code class="language-shell">podman unshare &lt;command&gt;
</code></pre>
<h3 id="run-a-k8s-pod-manifest-with-podman"><a class="header" href="#run-a-k8s-pod-manifest-with-podman">Run a k8s Pod manifest with Podman</a></h3>
<pre><code class="language-shell">podman play kube pod.yml 
</code></pre>
<p>Killing the same pod:</p>
<pre><code class="language-shell">podman play kube --down pod.yml
</code></pre>
<hr />
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<h3 id="forcefully-remove-every-containerimage"><a class="header" href="#forcefully-remove-every-containerimage">Forcefully remove every <code>&lt;container/image&gt;</code></a></h3>
<pre><code class="language-bash">docker container rm -f $(docker &lt;container/image&gt; ls -aq)
</code></pre>
<h3 id="forcefully-remove-every-volumenetwork"><a class="header" href="#forcefully-remove-every-volumenetwork">Forcefully remove every <code>&lt;volume/network&gt;</code></a></h3>
<pre><code class="language-bash">docker container rm -f $(docker &lt;volume/network&gt; ls -aq)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-useful-commands"><a class="header" href="#kubernetes-useful-commands">Kubernetes useful commands</a></h1>
<h2 id="kubectl"><a class="header" href="#kubectl">Kubectl</a></h2>
<h3 id="create-secrets"><a class="header" href="#create-secrets">Create secrets</a></h3>
<p>.secrets.txt</p>
<pre><code>email=example@example.com
password=secret
</code></pre>
<pre><code class="language-bash">kubectl create secret generic &quot;cloudflare-ddns&quot; --from-env-file=./.secrets
</code></pre>
<h3 id="edit-live-deployment"><a class="header" href="#edit-live-deployment">Edit live deployment</a></h3>
<pre><code class="language-shell">kubectl edit deployment &lt;deployment-name&gt;
</code></pre>
<h3 id="quick-port-forwarding"><a class="header" href="#quick-port-forwarding">Quick port forwarding</a></h3>
<pre><code class="language-shell">kubectl port-forward deployments/&lt;deployment-name&gt; &lt;host-port&gt;:&lt;container-port&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-oneliners"><a class="header" href="#networking-oneliners">Networking Oneliners</a></h1>
<h2 id="netstats"><a class="header" href="#netstats">Netstats</a></h2>
<h3 id="check-open-ports"><a class="header" href="#check-open-ports">Check open ports</a></h3>
<p>With <strong>Netstats</strong></p>
<pre><code class="language-sh"> netstat -ltnp | grep -w ':80' 
</code></pre>
<ul>
<li><code>l</code> – tells netstat to only show listening sockets.</li>
<li><code>t</code> – tells it to display tcp connections.</li>
<li><code>n</code> – instructs it show numerical addresses.</li>
<li><code>p</code> – enables showing of the process ID and the process name.</li>
<li><code>grep -w</code> – shows matching of exact string (:80).</li>
</ul>
<h2 id="lsof"><a class="header" href="#lsof">lsof</a></h2>
<h3 id="check-open-ports-1"><a class="header" href="#check-open-ports-1">Check open ports</a></h3>
<pre><code class="language-shell">lsof -i :80
</code></pre>
<h2 id="nmap"><a class="header" href="#nmap">nmap</a></h2>
<h3 id="simply-scan-a-network-or-host"><a class="header" href="#simply-scan-a-network-or-host">Simply scan a network or host</a></h3>
<p>Get open ports (most commons are scanned) and more info about the host.</p>
<pre><code class="language-bash">nmap 192.168.100.0/24
</code></pre>
<p><code>-sP</code> flag skips port scanning.</p>
<h3 id="get-info-about-a-device-in-a-network"><a class="header" href="#get-info-about-a-device-in-a-network">Get info about a device in a network</a></h3>
<pre><code class="language-bash">sudo nmap -p 0-65535 -O &lt;IP&gt;
</code></pre>
<p>This command need to be ran as <strong>sudo</strong> <code>-O</code> enables OS detection, <code>-p &lt;port ranges&gt;</code> only scans specified ports. Additionally you can try <code>-sV</code>, it probes open ports to determine service/version info.</p>
<h4 id="cve-detection-using-nmap"><a class="header" href="#cve-detection-using-nmap">CVE detection using Nmap</a></h4>
<pre><code class="language-bash">nmap -Pn --script vuln &lt;IP&gt;
</code></pre>
<p><code>-Pn</code> treats all hosts as online -- skip host discovery while <code>--script</code>
executes a set of Nmap built-in scripts</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">MySQL</a></h1>
<h3 id="check-which-threads-are-running"><a class="header" href="#check-which-threads-are-running">Check which threads are running.</a></h3>
<p><code>SHOW PROCESSLIST</code> shows you which threads are running. You can also get this information from the <code>information_schema.PROCESSLIST</code> table or the <code>mysqladmin processlist</code> command. If you have the <code>PROCESS privilege</code>, you can see all threads. Otherwise, you can see only your own threads (that is, threads associated with the MariaDB (MySQL) account that you are using).</p>
<pre><code class="language-mysql">SHOW FULL PROCESSLIST;
</code></pre>
<p>If you do not use the <code>FULL</code> keyword, only the first 100 characters of each statement are shown in the Info field.</p>
<h2 id="dumping-data-from-a-mysql-docker-container"><a class="header" href="#dumping-data-from-a-mysql-docker-container">Dumping data from a MySQL Docker container</a></h2>
<p>Are you one of those who does not like to have <code>mysql-server</code> installed on your machine ?  Do you use <strong>MySQL</strong> in <strong>Docker + MyCli</strong> for your development environments ? Having any trouble dumping data ?</p>
<p>Here you go:</p>
<pre><code class="language-bash">
# Backup
docker exec CONTAINER /usr/bin/mysqldump -u root --password=root DATABASE &gt; backup.sql

# Backup create only 
docker exec CONTAINER /usr/bin/mysqldump -u root --password=toor --no-data --compact polpdb | egrep -v &quot;(^SET|^/\*\!)&quot; | sed 's/ AUTO_INCREMENT=[0-9]*\b//'

# Restore
cat backup.sql | docker exec -i CONTAINER /usr/bin/mysql -u root --password=root DATABASE
</code></pre>
<h2 id="dumping-data-with-a-mysql-docker-container"><a class="header" href="#dumping-data-with-a-mysql-docker-container">Dumping data with a MySQL Docker container</a></h2>
<pre><code class="language-shell">docker run -it mysql:5.7 /usr/bin/mysqldump  -h [MYSQL_HOST] -u [MYSQL_USER] -P 6612 --password=[MYSQL_PASSWORD]   [MYSQL_DATABASE] &gt; backup.sql
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="delete-history-in-remote-repo"><a class="header" href="#delete-history-in-remote-repo">Delete history in remote repo</a></h2>
<p>Deleting the <code>.git</code> folder may cause problems in your git repository. If you want to delete all your commit history but keep the code in its current state, it is very safe to do it as in the following:</p>
<ol>
<li>
<p><strong>Checkout</strong></p>
<p><code>git checkout --orphan latest_branch</code></p>
</li>
<li>
<p><strong>Add all the files</strong></p>
<p><code>git add -A</code></p>
</li>
<li>
<p><strong>Commit the changes</strong></p>
<p><code>git commit -am &quot;commit message&quot;</code></p>
</li>
<li>
<p><strong>Delete the branch</strong></p>
<p><code>git branch -D &lt;branchName&gt;</code></p>
</li>
<li>
<p><strong>Rename the current branch to master</strong></p>
<p><code>git branch -m &lt;branchName&gt;</code></p>
</li>
<li>
<p><strong>Finally, force update your repository</strong></p>
<p><code>git push -f origin &lt;branchName&gt;</code></p>
</li>
</ol>
<p>PS: this will not keep your old commit history around. It will keep just your last commit so be sure not to have sensible data on that one.</p>
<h2 id="update-last-pushed-commit-name"><a class="header" href="#update-last-pushed-commit-name">Update last pushed commit name</a></h2>
<ol>
<li>
<p><strong>Ammend</strong>
<code> git commit --amend</code></p>
</li>
<li>
<p><strong>Force push</strong>
<code>git push --force</code></p>
</li>
</ol>
<h2 id="update-last-n-commits-name-tbc"><a class="header" href="#update-last-n-commits-name-tbc">Update last N commits name (TBC)</a></h2>
<ol>
<li><strong>Rebase</strong></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
